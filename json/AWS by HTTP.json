{
    "zabbix_export": {
        "version": "7.0",
        "template_groups": [
            {
                "uuid": "c2c162144c2d4c5491c8801193af4945",
                "name": "Templates/Cloud"
            }
        ],
        "host_groups": [
            {
                "uuid": "a571c0d144b14fd4a87a9d9b2aa9fcd6",
                "name": "Applications"
            },
            {
                "uuid": "748ad4d098d447d492bb935c907f652f",
                "name": "Databases"
            },
            {
                "uuid": "137f19e6e2dc4219b33553b812627bc2",
                "name": "Virtual machines"
            }
        ],
        "templates": [
            {
                "uuid": "c60e5929ab474f67bbe67dc6b04e709d",
                "template": "AWS by HTTP",
                "name": "AWS by HTTP",
                "description": "Get AWS EC2, RDS and S3 instances, AWS ECS clusters, AWS Elastic Load Balancing. Don't forget to read the README.md for the correct setup of the template.\n\nYou can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback\n\nGenerated by official Zabbix template tool \"Templator\"",
                "vendor": {
                    "name": "Zabbix",
                    "version": "7.0-0"
                },
                "groups": [
                    {
                        "name": "Templates/Cloud"
                    }
                ],
                "discovery_rules": [
                    {
                        "uuid": "c651911bad9244ad9c8d2dad5b0d70e4",
                        "name": "EC2 instances discovery",
                        "type": "SCRIPT",
                        "key": "aws.ec2.discovery",
                        "delay": "12h",
                        "params": "var AWS = {\n\tparams: {},\n\tmetadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',\n\n\tgetField: function (data, path) {\n\t\tvar steps = path.split('.');\n\t\tfor (var i = 0; i < steps.length; i++) {\n\t\t\tvar step = steps[i];\n\t\t\tif (typeof data !== 'object' || typeof data[step] === 'undefined') {\n\t\t\t\tthrow 'Required field was not found: ' + path;\n\t\t\t}\n\n\t\t\tdata = data[step];\n\t\t}\n\n\t\treturn data;\n\t},\n\n\tsetParams: function (params) {\n\t\tAWS.params['proxy'] = params.proxy;\n\t\tswitch (AWS.getField(params, 'auth_type')) {\n\t\t\tcase 'role_base':\n\t\t\t\tAWS.params['auth_type'] = 'role_base';\n\t\t\t\tvar request = new HttpRequest();\n\t\t\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t\t\t}\n\t\t\t\tvar IamRoleName = request.get(AWS.metadata);\n\n\t\t\t\tif (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata. Role not found.';\n\t\t\t\t}\n\n\t\t\t\tcredentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));\n\n\t\t\t\tif (request.getStatus() !== 200 || credentials === null || credentials === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata.';\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcredentials = JSON.parse(credentials);\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\tthrow 'Failed to parse response received from instance metadata. Check debug log for more information.';\n\t\t\t\t}\n\n\t\t\t\t['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {\n\t\t\t\t\tif (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {\n\t\t\t\t\t\tthrow 'Required credentials is not set: \"' + field + '\".';\n\t\t\t\t\t};\n\t\t\t\t\tAWS.params[field] = credentials[field];\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'access_key':\n\t\t\tdefault:\n\t\t\t\tAWS.params['auth_type'] = 'access_key';\n\t\t\t\t['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {\n\t\t\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t\t\t}\n\t\t\t\t\tAWS.params[field] = params[field];\n\t\t\t\t});\n\t\t}\n\t\t['region_match', 'region_not_match'].forEach(function (field) {\n\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t}\n\t\t\tAWS.params[field] = params[field];\n\t\t});\n\t},\n\n\tsign: function (key, message) {\n\t\tvar hex = hmac('sha256', key, message);\n\n\t\tif ((hex.length % 2) === 1) {\n\t\t\tthrow 'Invalid length of a hex string!';\n\t\t}\n\n\t\tvar result = new Int8Array(hex.length / 2);\n\t\tfor (var i = 0, b = 0; i < hex.length; i += 2, b++) {\n\t\t\tresult[b] = parseInt(hex.substring(i, i + 2), 16);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tprepareParams: function (params) {\n\t\tvar result = [];\n\n\t\tObject.keys(params).sort().forEach(function (key) {\n\t\t\tif (typeof params[key] !== 'object') {\n\t\t\t\tresult.push(key + '=' + encodeURIComponent(params[key]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.push(prepareObject(key, params[key]));\n\t\t\t}\n\t\t});\n\n\t\treturn result.join('&');\n\t},\n\n\trequest: function (method, region, service, host, params, data, uri) {\n\t\tif (typeof data === 'undefined' || data === null) {\n\t\t\tdata = '';\n\t\t}\n\n\t\tvar amzdate = (new Date()).toISOString().replace(/\\.\\d+Z/, 'Z').replace(/[-:]/g, ''),\n\t\t\tdate = amzdate.replace(/T\\d+Z/, ''),\n\n\t\t\tcanonical_uri = '/' + uri,\n\t\t\tcanonical_headers = 'content-encoding:amz-1.0\\n' + 'host:' + host + '\\n' + 'x-amz-date:' + amzdate + '\\n',\n\t\t\tsigned_headers = 'content-encoding;host;x-amz-date',\n\t\t\tcanonical_request = method + '\\n' + canonical_uri + '\\n' + params + '\\n' + canonical_headers + '\\n' + signed_headers + '\\n' + sha256(data),\n\t\t\tcredential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',\n\t\t\trequest_string = 'AWS4-HMAC-SHA256' + '\\n' + amzdate + '\\n' + credential_scope + '\\n' + sha256(canonical_request),\n\t\t\tkey = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);\n\n\t\tkey = AWS.sign(key, region);\n\t\tkey = AWS.sign(key, service);\n\t\tkey = AWS.sign(key, 'aws4_request');\n\n\t\tvar request = new HttpRequest(),\n\t\t\turl = 'https://' + host + canonical_uri + '?' + params;\n\n\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t}\n\t\trequest.addHeader('x-amz-date: ' + amzdate);\n\t\trequest.addHeader('x-amz-content-sha256:' + sha256(data));\n\t\trequest.addHeader('Accept: application/json');\n\t\trequest.addHeader('Content-Type: application/json');\n\t\trequest.addHeader('Content-Encoding: amz-1.0');\n\t\trequest.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));\n\t\tif (AWS.params.auth_type === 'role_base')\n\t\t\trequest.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);\n\n\t\tZabbix.log(4, '[ AWS EC2 ] Sending request: ' + url);\n\n\t\tresponse = request.post(url, data);\n\n\t\tZabbix.log(4, '[ AWS EC2 ] Received response with status code ' + request.getStatus() + ': ' + response);\n\n\t\tif (request.getStatus() !== 200) {\n\t\t\tthrow 'Request failed with status code ' + request.getStatus() + ': ' + response;\n\t\t}\n\t\tif (response !== null) {\n\t\t\ttry {\n\t\t\t\tresponse = XML.toJson(response);\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tthrow 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';\n\t\t\t}\n\t\t}\n\n\t\treturn JSON.parse(response);\n\t},\n\n\ttagToNameInstances: function (instance) {\n\t\ttry {\n\t\t\tvar tags = AWS.getField(instance, 'tagSet.item'),\n\t\t\t\tinstanceName = AWS.getField(instance, 'instanceId');\n\t\t\tif (!Array.isArray(tags))\n\t\t\t\ttags = [tags]\n\t\t\ttags.forEach(\n\t\t\t\tfunction (tag) {\n\t\t\t\t\tif (String(AWS.getField(tag, 'key')) === 'Name') {\n\t\t\t\t\t\tinstanceName = AWS.getField(tag, 'value');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn instanceName;\n\t\t}\n\t\tcatch (error){\n\t\t\treturn AWS.getField(instance, 'instanceId');\n\t\t}\n\t},\n\n\tlistRegions: function () {\n\t\tvar payload = {\n\t\t\t'Action': 'DescribeRegions',\n\t\t\t'Version': '2016-11-15'\n\t\t};\n\n\t\tresult = AWS.request('POST', 'us-east-1', 'ec2', 'ec2.amazonaws.com', AWS.prepareParams(payload), '', '');\n\n\t\tregions = AWS.getField(result, 'DescribeRegionsResponse.regionInfo.item')\n\t\tif (!Array.isArray(regions))\n\t\t\tregions = [regions]\n\t\treturn regions\n\t},\n\n\tlistInstances: function () {\n\t\tvar lld_array = [],\n\t\t\tregions = AWS.listRegions(),\n\t\t\tpayload = {\n\t\t\t\t'Action': 'DescribeInstances',\n\t\t\t\t'Version': '2016-11-15'\n\t\t\t};\n\n\t\tregions.forEach(function (region) {\n\t\t\tvar region_name = AWS.getField(region, 'regionName');\n\t\t\tif (region_name.match(AWS.params.region_match) === null ||\n\t\t\t\tregion_name.match(AWS.params.region_not_match) !== null)\n\t\t\t\treturn;\n\n\t\t\tresult = AWS.request('POST', region_name, 'ec2', AWS.getField(region, 'regionEndpoint'), AWS.prepareParams(payload), '', '');\n\n\t\t\tif (typeof result !== 'object'\n\t\t\t\t|| typeof result.DescribeInstancesResponse !== 'object'\n\t\t\t\t|| typeof result.DescribeInstancesResponse.reservationSet !== 'object') {\n\t\t\t\tthrow 'Cannot get EC2 instance list from AWS API. Check debug log for more information.';\n\t\t\t}\n\n\t\t\tif (result.DescribeInstancesResponse.reservationSet === null)\n\t\t\t\treturn [];\n\n\t\t\tif (typeof result.DescribeInstancesResponse.reservationSet.item !== 'object')\n\t\t\t\tthrow 'Cannot get EC2 instance list from AWS API. Check debug log for more information.';\n\n\t\t\tvar reservation = result.DescribeInstancesResponse.reservationSet.item\n\t\t\tif (!Array.isArray(reservation))\n\t\t\t\treservation = [reservation]\n\n\t\t\treservation.forEach(function (res_item) {\n\t\t\t\tvar instances = AWS.getField(res_item, 'instancesSet.item')\n\t\t\t\tif (!Array.isArray(instances))\n\t\t\t\t\tinstances = [instances]\n\t\t\t\tinstances.forEach(function (instance) {\n\t\t\t\t\tif (AWS.getField(instance, 'instanceState.name') === 'terminated') return;\n\t\t\t\t\tlld_array.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinstanceId: AWS.getField(instance, 'instanceId'),\n\t\t\t\t\t\t\tinstanceName: AWS.tagToNameInstances(instance),\n\t\t\t\t\t\t\tinstanceRegion: region_name\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\treturn lld_array;\n\t}\n};\n\ntry {\n\tAWS.setParams(JSON.parse(value));\n\n\treturn JSON.stringify(AWS.listInstances());\n}\ncatch (error) {\n\terror += (String(error).endsWith('.')) ? '' : '.';\n\tZabbix.log(3, '[ AWS EC2 ] ERROR: ' + error);\n\treturn JSON.stringify({ 'error': error });\n}",
                        "filter": {
                            "evaltype": "AND",
                            "conditions": [
                                {
                                    "macro": "{#AWS.EC2.INSTANCE.NAME}",
                                    "value": "{$AWS.EC2.LLD.FILTER.NAME.MATCHES}",
                                    "formulaid": "A"
                                },
                                {
                                    "macro": "{#AWS.EC2.INSTANCE.NAME}",
                                    "value": "{$AWS.EC2.LLD.FILTER.NAME.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "B"
                                },
                                {
                                    "macro": "{#AWS.EC2.INSTANCE.REGION}",
                                    "value": "{$AWS.EC2.LLD.FILTER.REGION.MATCHES}",
                                    "formulaid": "C"
                                },
                                {
                                    "macro": "{#AWS.EC2.INSTANCE.REGION}",
                                    "value": "{$AWS.EC2.LLD.FILTER.REGION.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "D"
                                }
                            ]
                        },
                        "description": "Get EC2 instances.",
                        "host_prototypes": [
                            {
                                "uuid": "c4c830c727294b07926c39b00cf19046",
                                "host": "{#AWS.EC2.INSTANCE.ID}",
                                "name": "{#AWS.EC2.INSTANCE.NAME}",
                                "group_links": [
                                    {
                                        "group": {
                                            "name": "Virtual machines"
                                        }
                                    }
                                ],
                                "templates": [
                                    {
                                        "name": "AWS EC2 by HTTP"
                                    }
                                ],
                                "macros": [
                                    {
                                        "macro": "{$AWS.EC2.INSTANCE.ID}",
                                        "value": "{#AWS.EC2.INSTANCE.ID}",
                                        "description": "EC2 instance ID."
                                    },
                                    {
                                        "macro": "{$AWS.REGION}",
                                        "value": "{#AWS.EC2.INSTANCE.REGION}",
                                        "description": "Amazon EC2 Region code."
                                    }
                                ],
                                "tags": [
                                    {
                                        "tag": "name",
                                        "value": "{#AWS.EC2.INSTANCE.NAME}"
                                    },
                                    {
                                        "tag": "region",
                                        "value": "{#AWS.EC2.INSTANCE.REGION}"
                                    },
                                    {
                                        "tag": "service",
                                        "value": "ec2"
                                    }
                                ],
                                "custom_interfaces": "YES",
                                "interfaces": [
                                    {
                                        "ip": "{#AWS.EC2.INSTANCE.ID}"
                                    }
                                ]
                            }
                        ],
                        "timeout": "{$AWS.DATA.TIMEOUT}",
                        "parameters": [
                            {
                                "name": "AccessKeyId",
                                "value": "{$AWS.ACCESS.KEY.ID}"
                            },
                            {
                                "name": "auth_type",
                                "value": "{$AWS.AUTH_TYPE}"
                            },
                            {
                                "name": "proxy",
                                "value": "{$AWS.PROXY}"
                            },
                            {
                                "name": "region_match",
                                "value": "{$AWS.EC2.LLD.FILTER.REGION.MATCHES}"
                            },
                            {
                                "name": "region_not_match",
                                "value": "{$AWS.EC2.LLD.FILTER.REGION.NOT_MATCHES}"
                            },
                            {
                                "name": "SecretAccessKey",
                                "value": "{$AWS.SECRET.ACCESS.KEY}"
                            }
                        ],
                        "lld_macro_paths": [
                            {
                                "lld_macro": "{#AWS.EC2.INSTANCE.ID}",
                                "path": "$.instanceId"
                            },
                            {
                                "lld_macro": "{#AWS.EC2.INSTANCE.NAME}",
                                "path": "$.instanceName"
                            },
                            {
                                "lld_macro": "{#AWS.EC2.INSTANCE.REGION}",
                                "path": "$.instanceRegion"
                            }
                        ]
                    },
                    {
                        "uuid": "44b68894d68c45ec9a5ea787c975ae16",
                        "name": "ECS clusters discovery",
                        "type": "SCRIPT",
                        "key": "aws.ecs.discovery",
                        "delay": "12h",
                        "params": "var AWS = {\n\tparams: {},\n\tmetadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',\n\n\tsetParams: function (params) {\n\t\tAWS.params['proxy'] = params.proxy;\n\t\tswitch (AWS.getField(params, 'auth_type')) {\n\t\t\tcase 'role_base':\n\t\t\t\tAWS.params['auth_type'] = 'role_base';\n\t\t\t\tvar request = new HttpRequest();\n\t\t\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t\t\t}\n\t\t\t\tvar IamRoleName = request.get(AWS.metadata);\n\n\t\t\t\tif (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata. Role not found.';\n\t\t\t\t}\n\n\t\t\t\tcredentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));\n\n\t\t\t\tif (request.getStatus() !== 200 || credentials === null || credentials === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata.';\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcredentials = JSON.parse(credentials);\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\tthrow 'Failed to parse response received from instance metadata. Check debug log for more information.';\n\t\t\t\t}\n\n\t\t\t\t['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {\n\t\t\t\t\tif (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {\n\t\t\t\t\t\tthrow 'Required credentials is not set: \"' + field + '\".';\n\t\t\t\t\t};\n\t\t\t\t\tAWS.params[field] = credentials[field];\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'access_key':\n\t\t\tdefault:\n\t\t\t\tAWS.params['auth_type'] = 'access_key';\n\t\t\t\t['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {\n\t\t\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t\t\t}\n\t\t\t\t\tAWS.params[field] = params[field];\n\t\t\t\t});\n\t\t}\n\t\t['region_match', 'region_not_match'].forEach(function (field) {\n\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t}\n\t\t\tAWS.params[field] = params[field];\n\t\t});\n\t},\n\n\tgetField: function (data, path) {\n\t\tvar steps = path.split('.');\n\t\tfor (var i = 0; i < steps.length; i++) {\n\t\t\tvar step = steps[i];\n\t\t\tif (typeof data !== 'object' || typeof data[step] === 'undefined') {\n\t\t\t\tthrow 'Required field was not found: ' + path;\n\t\t\t}\n\t\t\tdata = data[step];\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tsign: function (key, message) {\n\t\tvar hex = hmac('sha256', key, message);\n\t\tif ((hex.length % 2) === 1) {\n\t\t\tthrow 'Invalid length of a hex string!';\n\t\t}\n\t\tvar result = new Int8Array(hex.length / 2);\n\t\tfor (var i = 0, b = 0; i < hex.length; i += 2, b++) {\n\t\t\tresult[b] = parseInt(hex.substring(i, i + 2), 16);\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tprepareParams: function (params) {\n\t\tvar result = [];\n\t\tObject.keys(params).sort().forEach(function (key) {\n\t\t\tif (typeof params[key] !== 'object') {\n\t\t\t\tresult.push(key + '=' + encodeURIComponent(params[key]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.push(prepareObject(key, params[key]));\n\t\t\t}\n\t\t});\n\n\t\treturn result.join('&');\n\n\t},\n\n\trequest: function (method, region, service, host, params, data, uri) {\n\t\tif (typeof data === 'undefined' || data === null) {\n\t\t\tdata = '';\n\t\t}\n\t\tvar amzdate = (new Date()).toISOString().replace(/\\.\\d+Z/, 'Z').replace(/[-:]/g, ''),\n\t\t\tdate = amzdate.replace(/T\\d+Z/, ''),\n\t\t\tcanonical_uri = '/' + uri,\n\t\t\tcanonical_headers = 'content-encoding:amz-1.0\\n' + 'host:' + host + '\\n' + 'x-amz-date:' + amzdate + '\\n',\n\t\t\tsigned_headers = 'content-encoding;host;x-amz-date',\n\t\t\tcanonical_request = method + '\\n' + canonical_uri + '\\n' + params + '\\n' + canonical_headers + '\\n' + signed_headers + '\\n' + sha256(data),\n\t\t\tcredential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',\n\t\t\trequest_string = 'AWS4-HMAC-SHA256' + '\\n' + amzdate + '\\n' + credential_scope + '\\n' + sha256(canonical_request),\n\t\t\tkey = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);\n\t\tkey = AWS.sign(key, region);\n\t\tkey = AWS.sign(key, service);\n\t\tkey = AWS.sign(key, 'aws4_request');\n\t\tvar request = new HttpRequest(),\n\t\t\turl = 'https://' + host + canonical_uri + '?' + params;\n\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t}\n\t\trequest.addHeader('x-amz-date: ' + amzdate);\n\t\trequest.addHeader('x-amz-content-sha256:' + sha256(data));\n\t\trequest.addHeader('Accept: application/json');\n\t\trequest.addHeader('Content-Type: application/x-www-form-urlencoded');\n\t\trequest.addHeader('Content-Encoding: amz-1.0');\n\t\trequest.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));\n\t\tif (AWS.params.auth_type === 'role_base')\n\t\t\trequest.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);\n\n\t\tZabbix.log(4, '[ AWS ECS ] Sending request: ' + url);\n\n\t\tresponse = request.post(url, data);\n\n\t\tZabbix.log(4, '[ AWS ECS ] Received response with status code ' + request.getStatus() + ': ' + response);\n\n\t\tif (request.getStatus() !== 200) {\n\t\t\tthrow 'Request failed with status code ' + request.getStatus() + ': ' + response;\n\t\t}\n\t\ttry {\n\t\t\tresponse = JSON.parse(response);\n\t\t}\n\t\tcatch (error) {\n\t\t\ttry {\n\t\t\t\tresponse = JSON.parse(XML.toJson(response));\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tthrow 'Failed to parse response received from AWS API. Check debug log for more information.';\n\t\t\t}\n\t\t}\n\n\t\treturn response;\n\n\t},\n\n\tlistRegions: function () {\n\t\tvar payload = {\n\t\t\t'Action': 'DescribeRegions',\n\t\t\t'Version': '2016-11-15'\n\t\t};\n\n\t\tresult = AWS.request('POST', 'us-east-1', 'ec2', 'ec2.amazonaws.com', AWS.prepareParams(payload), '', '');\n\n\t\tregions = AWS.getField(result, 'DescribeRegionsResponse.regionInfo.item')\n\t\tif (!Array.isArray(regions))\n\t\t\tregions = [regions]\n\t\treturn regions\n\t},\n\n\tlistClusters: function () {\n\t\tvar data = [],\n\t\t\tregions = AWS.listRegions(),\n\t\t\tresult,\n\t\t\tECSClusters,\n\t\t\tpayload = {\n\t\t\t\t'Action': 'ListClusters',\n\t\t\t\t'Version': '2014-11-13'\n\t\t\t};\n\n\t\tregions.forEach(function (region) {\n\t\t\tvar region_name = AWS.getField(region, 'regionName');\n\t\t\tif (region_name.match(AWS.params.region_match) === null ||\n\t\t\t\tregion_name.match(AWS.params.region_not_match) !== null)\n\t\t\t\treturn;\n\n\t\t\tresult = AWS.request('POST', region_name, 'ecs', 'ecs.' + region_name + '.amazonaws.com', AWS.prepareParams(payload), '', '');\n\t\t\tECSClusters = AWS.getField(result, 'ListClustersResponse.ListClustersResult.clusterArns')\n\t\t\tfor (k in ECSClusters) {\n\t\t\t\tclusters = ECSClusters[k];\n\t\t\t\tjson = {};\n\t\t\t\tinput = clusters.split('/');\n\t\t\t\tfor (var i = 1; i < input.length; i += 2) {\n\t\t\t\t\tjson[input[i]] = input[i + 1];\n\t\t\t\t}\n\t\t\t\tdata.push({\n\t\t\t\t\t'clusters_name': input[1],\n\t\t\t\t\t'region': region_name\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\treturn data;\n\t},\n\n\tdecribeClusters: function (cluster_name, region_name) {\n\t\tvar payload = {},\n\t\t\tresult;\n\t\tpayload['Action'] = 'DescribeClusters';\n\t\tpayload['Version'] = '2014-11-13';\n\t\tpayload['clusters.clusterName'] = cluster_name;\n\t\tpayload['include.statistics'] = 'STATISTICS';\n\t\tresult = AWS.request('POST', region_name, 'ecs', 'ecs.' + region_name + '.amazonaws.com', AWS.prepareParams(payload), '', '');\n\n\t\treturn result;\n\n\t}\n\n};\n\ntry {\n\tAWS.setParams(JSON.parse(value));\n\tvar clusters = AWS.listClusters(),\n\t\tinfrastructure = [],\n\t\tmetrics = ['runningEC2TasksCount', 'pendingEC2TasksCount', 'activeEC2ServiceCount', 'drainingEC2ServiceCount'],\n\t\tECSClusters = [],\n\t\tDescribeClusters = [];\n\tDescribeClusters = clusters.map(function (cluster) {\n\t\tECSClusters = AWS.getField(AWS.decribeClusters(cluster.clusters_name, cluster.region), 'DescribeClustersResponse.DescribeClustersResult.clusters')\n\t\tfor (k in ECSClusters) {\n\t\t\tvar ECS2 = 0;\n\t\t\tstatistic = AWS.getField(ECSClusters[k], 'statistics');\n\t\t\tstatistic.forEach(function (id) {\n\t\t\t\tfor (i in metrics) {\n\t\t\t\t\tif (AWS.getField(id, 'name') === metrics[i]) {\n\t\t\t\t\t\tECS2 += Number(AWS.getField(id, 'value'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\tinfrastructure = (ECS2 > 0) ? 'use_ecs2' : 'serverless';\n\n\t\t\treturn {\n\t\t\t\t'clusterName': ECSClusters[k].clusterName,\n\t\t\t\t'status': ECSClusters[k].status,\n\t\t\t\t'infrastructure': infrastructure,\n\t\t\t\t'region': cluster.region\n\t\t\t}\n\n\t\t}\n\t})\n\treturn JSON.stringify(DescribeClusters);\n}\ncatch (error) {\n\terror += (String(error).endsWith('.')) ? '' : '.';\n\tZabbix.log(3, '[ AWS ECS ] ERROR: ' + error);\n\treturn JSON.stringify({ 'error': error });\n}",
                        "filter": {
                            "evaltype": "AND",
                            "conditions": [
                                {
                                    "macro": "{#AWS.ECS.CLUSTER.NAME}",
                                    "value": "{$AWS.ECS.LLD.FILTER.NAME.MATCHES}",
                                    "formulaid": "A"
                                },
                                {
                                    "macro": "{#AWS.ECS.CLUSTER.NAME}",
                                    "value": "{$AWS.ECS.LLD.FILTER.NAME.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "B"
                                },
                                {
                                    "macro": "{#AWS.ECS.CLUSTER.REGION}",
                                    "value": "{$AWS.ECS.LLD.FILTER.REGION.MATCHES}",
                                    "formulaid": "C"
                                },
                                {
                                    "macro": "{#AWS.ECS.CLUSTER.REGION}",
                                    "value": "{$AWS.ECS.LLD.FILTER.REGION.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "D"
                                },
                                {
                                    "macro": "{#AWS.ECS.CLUSTER.STATUS}",
                                    "value": "{$AWS.ECS.LLD.FILTER.STATUS.MATCHES}",
                                    "formulaid": "E"
                                },
                                {
                                    "macro": "{#AWS.ECS.CLUSTER.STATUS}",
                                    "value": "{$AWS.ECS.LLD.FILTER.STATUS.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "F"
                                }
                            ]
                        },
                        "description": "Get ECS clusters.",
                        "host_prototypes": [
                            {
                                "uuid": "71072e5a149e45b293946866f8220c07",
                                "host": "{#AWS.ECS.CLUSTER.NAME}",
                                "name": "{#AWS.ECS.CLUSTER.NAME}",
                                "group_links": [
                                    {
                                        "group": {
                                            "name": "Applications"
                                        }
                                    }
                                ],
                                "macros": [
                                    {
                                        "macro": "{$AWS.ECS.CLUSTER.NAME}",
                                        "value": "{#AWS.ECS.CLUSTER.NAME}",
                                        "description": "ECS cluster name."
                                    },
                                    {
                                        "macro": "{$AWS.REGION}",
                                        "value": "{#AWS.ECS.CLUSTER.REGION}",
                                        "description": "ECS cluster region."
                                    }
                                ],
                                "tags": [
                                    {
                                        "tag": "name",
                                        "value": "{#AWS.ECS.CLUSTER.NAME}"
                                    },
                                    {
                                        "tag": "region",
                                        "value": "{#AWS.ECS.CLUSTER.REGION}"
                                    },
                                    {
                                        "tag": "service",
                                        "value": "ecs"
                                    }
                                ]
                            }
                        ],
                        "timeout": "{$AWS.DATA.TIMEOUT}",
                        "parameters": [
                            {
                                "name": "AccessKeyId",
                                "value": "{$AWS.ACCESS.KEY.ID}"
                            },
                            {
                                "name": "auth_type",
                                "value": "{$AWS.AUTH_TYPE}"
                            },
                            {
                                "name": "proxy",
                                "value": "{$AWS.PROXY}"
                            },
                            {
                                "name": "region_match",
                                "value": "{$AWS.ECS.LLD.FILTER.REGION.MATCHES}"
                            },
                            {
                                "name": "region_not_match",
                                "value": "{$AWS.ECS.LLD.FILTER.REGION.NOT_MATCHES}"
                            },
                            {
                                "name": "SecretAccessKey",
                                "value": "{$AWS.SECRET.ACCESS.KEY}"
                            }
                        ],
                        "lld_macro_paths": [
                            {
                                "lld_macro": "{#AWS.ECS.CLUSTER.INFRASTRUCTURE}",
                                "path": "$.infrastructure"
                            },
                            {
                                "lld_macro": "{#AWS.ECS.CLUSTER.NAME}",
                                "path": "$.clusterName"
                            },
                            {
                                "lld_macro": "{#AWS.ECS.CLUSTER.REGION}",
                                "path": "$.region"
                            },
                            {
                                "lld_macro": "{#AWS.ECS.CLUSTER.STATUS}",
                                "path": "$.status"
                            }
                        ],
                        "overrides": [
                            {
                                "name": "Serverless",
                                "step": "1",
                                "filter": {
                                    "conditions": [
                                        {
                                            "macro": "{#AWS.ECS.CLUSTER.INFRASTRUCTURE}",
                                            "value": "^serverless$",
                                            "formulaid": "A"
                                        }
                                    ]
                                },
                                "operations": [
                                    {
                                        "operationobject": "HOST_PROTOTYPE",
                                        "operator": "REGEXP",
                                        "templates": [
                                            {
                                                "name": "AWS ECS Serverless Cluster by HTTP"
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "name": "Use EC2 Infrastructure",
                                "step": "2",
                                "filter": {
                                    "conditions": [
                                        {
                                            "macro": "{#AWS.ECS.CLUSTER.INFRASTRUCTURE}",
                                            "value": "^use_ecs2$",
                                            "formulaid": "A"
                                        }
                                    ]
                                },
                                "operations": [
                                    {
                                        "operationobject": "HOST_PROTOTYPE",
                                        "operator": "REGEXP",
                                        "templates": [
                                            {
                                                "name": "AWS ECS Cluster by HTTP"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "uuid": "e7ac860c53bf403f9aee8cdd4b099c05",
                        "name": "ELB load balancers discovery",
                        "type": "SCRIPT",
                        "key": "aws.elb.discovery",
                        "delay": "12h",
                        "params": "var AWS = {\n\tparams: {},\n\tmetadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',\n\n\tgetField: function (data, path) {\n\t\tvar steps = path.split('.');\n\t\tfor (var i = 0; i < steps.length; i++) {\n\t\t\tvar step = steps[i];\n\t\t\tif (typeof data !== 'object' || typeof data[step] === 'undefined') {\n\t\t\t\tthrow 'Required field was not found: ' + path;\n\t\t\t}\n\n\t\t\tdata = data[step];\n\t\t}\n\n\t\treturn data;\n\t},\n\n\tsetParams: function (params) {\n\t\tAWS.params['proxy'] = params.proxy;\n\t\tswitch (AWS.getField(params, 'auth_type')) {\n\t\t\tcase 'role_base':\n\t\t\t\tAWS.params['auth_type'] = 'role_base';\n\t\t\t\tvar request = new HttpRequest();\n\t\t\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t\t\t}\n\t\t\t\tvar IamRoleName = request.get(AWS.metadata);\n\n\t\t\t\tif (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata. Role not found.';\n\t\t\t\t}\n\n\t\t\t\tcredentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));\n\n\t\t\t\tif (request.getStatus() !== 200 || credentials === null || credentials === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata.';\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcredentials = JSON.parse(credentials);\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\tthrow 'Failed to parse response received from instance metadata. Check debug log for more information.';\n\t\t\t\t}\n\n\t\t\t\t['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {\n\t\t\t\t\tif (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {\n\t\t\t\t\t\tthrow 'Required credentials is not set: \"' + field + '\".';\n\t\t\t\t\t};\n\t\t\t\t\tAWS.params[field] = credentials[field];\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'access_key':\n\t\t\tdefault:\n\t\t\t\tAWS.params['auth_type'] = 'access_key';\n\t\t\t\t['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {\n\t\t\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t\t\t}\n\t\t\t\t\tAWS.params[field] = params[field];\n\t\t\t\t});\n\t\t}\n\t\t['region_match', 'region_not_match'].forEach(function (field) {\n\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t}\n\t\t\tAWS.params[field] = params[field];\n\t\t});\n\t},\n\n\tsign: function (key, message) {\n\t\tvar hex = hmac('sha256', key, message);\n\n\t\tif ((hex.length % 2) === 1) {\n\t\t\tthrow 'Invalid length of a hex string!';\n\t\t}\n\n\t\tvar result = new Int8Array(hex.length / 2);\n\t\tfor (var i = 0, b = 0; i < hex.length; i += 2, b++) {\n\t\t\tresult[b] = parseInt(hex.substring(i, i + 2), 16);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tprepareParams: function (params) {\n\t\tvar result = [];\n\n\t\tObject.keys(params).sort().forEach(function (key) {\n\t\t\tif (typeof params[key] !== 'object') {\n\t\t\t\tresult.push(key + '=' + encodeURIComponent(params[key]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.push(prepareObject(key, params[key]));\n\t\t\t}\n\t\t});\n\n\t\treturn result.join('&');\n\t},\n\n\trequest: function (get, method, region, service, host, params, data, uri) {\n\t\tif (typeof data === 'undefined' || data === null) {\n\t\t\tdata = '';\n\t\t}\n\n\t\tvar amzdate = (new Date()).toISOString().replace(/\\.\\d+Z/, 'Z').replace(/[-:]/g, ''),\n\t\t\tdate = amzdate.replace(/T\\d+Z/, ''),\n\n\t\t\tcanonical_uri = '/' + uri,\n\t\t\tcanonical_headers = 'content-encoding:amz-1.0\\n' + 'host:' + host + '\\n' + 'x-amz-date:' + amzdate + '\\n',\n\t\t\tsigned_headers = 'content-encoding;host;x-amz-date',\n\t\t\tcanonical_request = method + '\\n' + canonical_uri + '\\n' + params + '\\n' + canonical_headers + '\\n' + signed_headers + '\\n' + sha256(data),\n\t\t\tcredential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',\n\t\t\trequest_string = 'AWS4-HMAC-SHA256' + '\\n' + amzdate + '\\n' + credential_scope + '\\n' + sha256(canonical_request),\n\t\t\tkey = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);\n\n\t\tkey = AWS.sign(key, region);\n\t\tkey = AWS.sign(key, service);\n\t\tkey = AWS.sign(key, 'aws4_request');\n\n\t\tvar request = new HttpRequest(),\n\t\t\turl = 'https://' + host + canonical_uri + '?' + params;\n\n\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t}\n\t\trequest.addHeader('x-amz-date: ' + amzdate);\n\t\trequest.addHeader('x-amz-content-sha256:' + sha256(data));\n\t\trequest.addHeader('Accept: application/json');\n\t\trequest.addHeader('Content-Type: application/json');\n\t\trequest.addHeader('Content-Encoding: amz-1.0');\n\t\trequest.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));\n\t\tif (AWS.params.auth_type === 'role_base')\n\t\t\trequest.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);\n\n\t\tswitch (get) {\n\t\t\tcase 'regions':\n\t\t\t\tZabbix.log(4, '[ AWS ELB ] Sending request: ' + url);\n\t\t\t\tresponse = request.post(url, data);\n\t\t\t\tZabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);\n\t\t\t\tif (request.getStatus() !== 200) {\n\t\t\t\t\tthrow 'Request failed with status code ' + request.getStatus() + ': ' + response;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tresponse = XML.toJson(response);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'balancer':\n\t\t\t\tZabbix.log(4, '[ AWS ELB ] Sending request: ' + url);\n\t\t\t\tresponse = request.get(url);\n\t\t\t\tZabbix.log(4, '[ AWS ELB ] Received response with status code ' + request.getStatus() + ': ' + response);\n\t\t\t\tif (request.getStatus() !== 200) {\n\t\t\t\t\tthrow 'Request failed with status code ' + request.getStatus() + ': ' + response;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow 'Error: Invalid option \"get\" for request function';\n\t\t}\n\n\t\treturn JSON.parse(response);\n\t},\n\n\tlistRegions: function () {\n\t\tvar payload = {\n\t\t\t'Action': 'DescribeRegions',\n\t\t\t'Version': '2016-11-15'\n\t\t};\n\n\t\tregions = AWS.getField(AWS.request('regions', 'POST', 'us-east-1', 'ec2', 'ec2.amazonaws.com', AWS.prepareParams(payload), '', ''), 'DescribeRegionsResponse.regionInfo.item');\n\n\t\tif (!Array.isArray(regions))\n\t\t\tregions = [regions]\n\t\treturn regions\n\t},\n\n\tlistLoadBalancers: function () {\n\t\tvar lld_array = [],\n\t\t\tregions = AWS.listRegions(),\n\t\t\tpayload = {\n\t\t\t\t'Action': 'DescribeLoadBalancers',\n\t\t\t\t'Version': '2015-12-01'\n\t\t\t};\n\n\t\tregions.forEach(function (region) {\n\t\t\tvar region_name = AWS.getField(region, 'regionName');\n\t\t\tif (region_name.match(AWS.params.region_match) === null ||\n\t\t\t\tregion_name.match(AWS.params.region_not_match) !== null)\n\t\t\t\treturn;\n\t\t\telb = AWS.getField(AWS.request('balancer', 'GET', region_name, 'elasticloadbalancing', 'elasticloadbalancing.' + region_name + '.amazonaws.com', AWS.prepareParams(payload), '', ''), 'DescribeLoadBalancersResponse.DescribeLoadBalancersResult.LoadBalancers');\n\t\t\tif (!Array.isArray(elb))\n\t\t\t\telb = [elb]\n\n\t\t\telb.forEach(function (elb) {\n\t\t\t\tlld_array.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: AWS.getField(elb, 'LoadBalancerName'),\n\t\t\t\t\t\tarn: AWS.getField(elb, 'LoadBalancerArn'),\n\t\t\t\t\t\ttype: AWS.getField(elb, 'Type'),\n\t\t\t\t\t\tstate: AWS.getField(elb, 'State.Code'),\n\t\t\t\t\t\tdns_name: AWS.getField(elb, 'DNSName'),\n\t\t\t\t\t\tregion: region_name\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t});\n\t\t});\n\n\t\treturn lld_array;\n\t}\n};\n\ntry {\n\tAWS.setParams(JSON.parse(value));\n\n\treturn JSON.stringify(AWS.listLoadBalancers());\n}\ncatch (error) {\n\terror += (String(error).endsWith('.')) ? '' : '.';\n\tZabbix.log(3, '[ AWS ELB ] ERROR: ' + error);\n\treturn JSON.stringify({ 'error': error });\n}",
                        "filter": {
                            "evaltype": "AND",
                            "conditions": [
                                {
                                    "macro": "{#AWS.ELB.NAME}",
                                    "value": "{$AWS.ELB.LLD.FILTER.NAME.MATCHES}",
                                    "formulaid": "A"
                                },
                                {
                                    "macro": "{#AWS.ELB.NAME}",
                                    "value": "{$AWS.ELB.LLD.FILTER.NAME.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "B"
                                },
                                {
                                    "macro": "{#AWS.ELB.REGION}",
                                    "value": "{$AWS.ELB.LLD.FILTER.REGION.MATCHES}",
                                    "formulaid": "C"
                                },
                                {
                                    "macro": "{#AWS.ELB.REGION}",
                                    "value": "{$AWS.ELB.LLD.FILTER.REGION.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "D"
                                },
                                {
                                    "macro": "{#AWS.ELB.STATE}",
                                    "value": "{$AWS.ELB.LLD.FILTER.STATE.MATCHES}",
                                    "formulaid": "E"
                                },
                                {
                                    "macro": "{#AWS.ELB.STATE}",
                                    "value": "{$AWS.ELB.LLD.FILTER.STATE.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "F"
                                }
                            ]
                        },
                        "description": "Get ELB load balancers.",
                        "host_prototypes": [
                            {
                                "uuid": "2c31bc79209e41978f76315406339769",
                                "host": "{#AWS.ELB.NAME}",
                                "name": "{#AWS.ELB.NAME}",
                                "group_links": [
                                    {
                                        "group": {
                                            "name": "Applications"
                                        }
                                    }
                                ],
                                "macros": [
                                    {
                                        "macro": "{$AWS.ELB.ARN}",
                                        "value": "{#AWS.ELB.ARN}",
                                        "description": "The Amazon Resource Names (ARN) of the load balancers."
                                    },
                                    {
                                        "macro": "{$AWS.ELB.NAME}",
                                        "value": "{#AWS.ELB.NAME}",
                                        "description": "ELB load balancer name."
                                    },
                                    {
                                        "macro": "{$AWS.REGION}",
                                        "value": "{#AWS.ELB.REGION}",
                                        "description": "ELB load balancer region."
                                    }
                                ],
                                "tags": [
                                    {
                                        "tag": "dns-name",
                                        "value": "{#AWS.ELB.DNS.NAME}"
                                    },
                                    {
                                        "tag": "name",
                                        "value": "{#AWS.ELB.NAME}"
                                    },
                                    {
                                        "tag": "region",
                                        "value": "{#AWS.ELB.REGION}"
                                    },
                                    {
                                        "tag": "service",
                                        "value": "elb"
                                    },
                                    {
                                        "tag": "type",
                                        "value": "{#AWS.ELB.TYPE}"
                                    }
                                ]
                            }
                        ],
                        "timeout": "{$AWS.DATA.TIMEOUT}",
                        "parameters": [
                            {
                                "name": "AccessKeyId",
                                "value": "{$AWS.ACCESS.KEY.ID}"
                            },
                            {
                                "name": "auth_type",
                                "value": "{$AWS.AUTH_TYPE}"
                            },
                            {
                                "name": "proxy",
                                "value": "{$AWS.PROXY}"
                            },
                            {
                                "name": "region_match",
                                "value": "{$AWS.ELB.LLD.FILTER.REGION.MATCHES}"
                            },
                            {
                                "name": "region_not_match",
                                "value": "{$AWS.ELB.LLD.FILTER.REGION.NOT_MATCHES}"
                            },
                            {
                                "name": "SecretAccessKey",
                                "value": "{$AWS.SECRET.ACCESS.KEY}"
                            }
                        ],
                        "lld_macro_paths": [
                            {
                                "lld_macro": "{#AWS.ELB.ARN}",
                                "path": "$.arn"
                            },
                            {
                                "lld_macro": "{#AWS.ELB.DNS.NAME}",
                                "path": "$.dns_name"
                            },
                            {
                                "lld_macro": "{#AWS.ELB.NAME}",
                                "path": "$.name"
                            },
                            {
                                "lld_macro": "{#AWS.ELB.REGION}",
                                "path": "$.region"
                            },
                            {
                                "lld_macro": "{#AWS.ELB.STATE}",
                                "path": "$.state"
                            },
                            {
                                "lld_macro": "{#AWS.ELB.TYPE}",
                                "path": "$.type"
                            }
                        ],
                        "overrides": [
                            {
                                "name": "Application Load Balancers",
                                "step": "1",
                                "filter": {
                                    "conditions": [
                                        {
                                            "macro": "{#AWS.ELB.TYPE}",
                                            "value": "^application$",
                                            "formulaid": "A"
                                        }
                                    ]
                                },
                                "operations": [
                                    {
                                        "operationobject": "HOST_PROTOTYPE",
                                        "operator": "REGEXP",
                                        "templates": [
                                            {
                                                "name": "AWS ELB Application Load Balancer by HTTP"
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "name": "Network Load Balancers",
                                "step": "2",
                                "filter": {
                                    "conditions": [
                                        {
                                            "macro": "{#AWS.ELB.TYPE}",
                                            "value": "^network$",
                                            "formulaid": "A"
                                        }
                                    ]
                                },
                                "operations": [
                                    {
                                        "operationobject": "HOST_PROTOTYPE",
                                        "operator": "REGEXP",
                                        "templates": [
                                            {
                                                "name": "AWS ELB Network Load Balancer by HTTP"
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "uuid": "c1127e674b7548b2802cd8771f3a4768",
                        "name": "RDS instances discovery",
                        "type": "SCRIPT",
                        "key": "aws.rds.discovery",
                        "delay": "12h",
                        "params": "var AWS = {\n\tparams: {},\n\tmetadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',\n\n\tgetField: function (data, path) {\n\t\tvar steps = path.split('.');\n\t\tfor (var i = 0; i < steps.length; i++) {\n\t\t\tvar step = steps[i];\n\t\t\tif (typeof data !== 'object' || typeof data[step] === 'undefined') {\n\t\t\t\tthrow 'Required field was not found: ' + path;\n\t\t\t}\n\n\t\t\tdata = data[step];\n\t\t}\n\n\t\treturn data;\n\t},\n\n\tsetParams: function (params) {\n\t\tAWS.params['proxy'] = params.proxy;\n\t\tswitch (AWS.getField(params, 'auth_type')) {\n\t\t\tcase 'role_base':\n\t\t\t\tAWS.params['auth_type'] = 'role_base';\n\t\t\t\tvar request = new HttpRequest();\n\t\t\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t\t\t}\n\t\t\t\tvar IamRoleName = request.get(AWS.metadata);\n\n\t\t\t\tif (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata. Role not found.';\n\t\t\t\t}\n\n\t\t\t\tcredentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));\n\n\t\t\t\tif (request.getStatus() !== 200 || credentials === null || credentials === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata.';\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcredentials = JSON.parse(credentials);\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\tthrow 'Failed to parse response received from instance metadata. Check debug log for more information.';\n\t\t\t\t}\n\n\t\t\t\t['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {\n\t\t\t\t\tif (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {\n\t\t\t\t\t\tthrow 'Required credentials is not set: \"' + field + '\".';\n\t\t\t\t\t};\n\t\t\t\t\tAWS.params[field] = credentials[field];\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'access_key':\n\t\t\tdefault:\n\t\t\t\tAWS.params['auth_type'] = 'access_key';\n\t\t\t\t['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {\n\t\t\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t\t\t}\n\t\t\t\t\tAWS.params[field] = params[field];\n\t\t\t\t});\n\t\t}\n\t\t['region_match', 'region_not_match'].forEach(function (field) {\n\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t}\n\t\t\tAWS.params[field] = params[field];\n\t\t});\n\t},\n\n\tsign: function (key, message) {\n\t\tvar hex = hmac('sha256', key, message);\n\n\t\tif ((hex.length % 2) === 1) {\n\t\t\tthrow 'Invalid length of a hex string!';\n\t\t}\n\n\t\tvar result = new Int8Array(hex.length / 2);\n\t\tfor (var i = 0, b = 0; i < hex.length; i += 2, b++) {\n\t\t\tresult[b] = parseInt(hex.substring(i, i + 2), 16);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tprepareParams: function (params) {\n\t\tvar result = [];\n\n\t\tObject.keys(params).sort().forEach(function (key) {\n\t\t\tif (typeof params[key] !== 'object') {\n\t\t\t\tresult.push(key + '=' + encodeURIComponent(params[key]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.push(prepareObject(key, params[key]));\n\t\t\t}\n\t\t});\n\n\t\treturn result.join('&');\n\t},\n\n\trequest: function (method, region, service, host, params, data, uri) {\n\t\tif (typeof data === 'undefined' || data === null) {\n\t\t\tdata = '';\n\t\t}\n\n\t\tvar amzdate = (new Date()).toISOString().replace(/\\.\\d+Z/, 'Z').replace(/[-:]/g, ''),\n\t\t\tdate = amzdate.replace(/T\\d+Z/, ''),\n\n\t\t\tcanonical_uri = '/' + uri,\n\t\t\tcanonical_headers = 'content-encoding:amz-1.0\\n' + 'host:' + host + '\\n' + 'x-amz-date:' + amzdate + '\\n',\n\t\t\tsigned_headers = 'content-encoding;host;x-amz-date',\n\t\t\tcanonical_request = method + '\\n' + canonical_uri + '\\n' + params + '\\n' + canonical_headers + '\\n' + signed_headers + '\\n' + sha256(data),\n\t\t\tcredential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',\n\t\t\trequest_string = 'AWS4-HMAC-SHA256' + '\\n' + amzdate + '\\n' + credential_scope + '\\n' + sha256(canonical_request),\n\t\t\tkey = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);\n\n\t\tkey = AWS.sign(key, region);\n\t\tkey = AWS.sign(key, service);\n\t\tkey = AWS.sign(key, 'aws4_request');\n\n\t\tvar request = new HttpRequest(),\n\t\t\turl = 'https://' + host + canonical_uri + '?' + params;\n\n\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t}\n\t\trequest.addHeader('x-amz-date: ' + amzdate);\n\t\trequest.addHeader('x-amz-content-sha256:' + sha256(data));\n\t\trequest.addHeader('Accept: application/json');\n\t\trequest.addHeader('Content-Type: application/json');\n\t\trequest.addHeader('Content-Encoding: amz-1.0');\n\t\trequest.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));\n\t\tif (AWS.params.auth_type === 'role_base')\n\t\t\trequest.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);\n\n\t\tZabbix.log(4, '[ AWS RDS ] Sending request: ' + url);\n\n\t\tresponse = request.post(url, data);\n\n\t\tZabbix.log(4, '[ AWS RDS ] Received response with status code ' + request.getStatus() + ': ' + response);\n\n\t\tif (request.getStatus() !== 200) {\n\t\t\tthrow 'Request failed with status code ' + request.getStatus() + ': ' + response;\n\t\t}\n\n\t\ttry {\n\t\t\tresponse = JSON.parse(response);\n\t\t}\n\t\tcatch (error) {\n\t\t\ttry {\n\t\t\t\tresponse = JSON.parse(XML.toJson(response));\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tthrow 'Failed to parse response received from AWS API. Check debug log for more information.';\n\t\t\t}\n\t\t}\n\n\t\treturn response;\n\t},\n\n\tlistRegions: function () {\n\t\tvar payload = {\n\t\t\t'Action': 'DescribeRegions',\n\t\t\t'Version': '2016-11-15'\n\t\t};\n\n\t\tresult = AWS.request('POST', 'us-east-1', 'ec2', 'ec2.amazonaws.com', AWS.prepareParams(payload), '', '');\n\n\t\tregions = AWS.getField(result, 'DescribeRegionsResponse.regionInfo.item')\n\t\tif (!Array.isArray(regions))\n\t\t\tregions = [regions]\n\t\treturn regions\n\t},\n\n\tlistInstances: function () {\n\t\tvar lld_array = [],\n\t\t\tregions = AWS.listRegions(),\n\t\t\tpayload = {\n\t\t\t\t'Action': 'DescribeDBInstances',\n\t\t\t\t'Version': '2014-10-31'\n\t\t\t};\n\n\t\tregions.forEach(function (region) {\n\t\t\tvar region_name = AWS.getField(region, 'regionName');\n\t\t\tif (region_name.match(AWS.params.region_match) === null ||\n\t\t\t\tregion_name.match(AWS.params.region_not_match) !== null)\n\t\t\t\treturn;\n\n\t\t\tresult = AWS.request('POST', region_name, 'rds', 'rds.' + region_name + '.amazonaws.com', AWS.prepareParams(payload), '', '');\n\n\t\t\tdatabases = AWS.getField(result, 'DescribeDBInstancesResponse.DescribeDBInstancesResult.DBInstances')\n\t\t\tif (!Array.isArray(databases))\n\t\t\t\tdatabases = [databases]\n\n\t\t\tdatabases.forEach(function (db) {\n\t\t\t\tlld_array.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tDBInstanceIdentifier: AWS.getField(db, 'DBInstanceIdentifier'),\n\t\t\t\t\t\tinstanceRegion: region_name\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t});\n\t\t});\n\n\t\treturn lld_array;\n\t}\n};\n\ntry {\n\tAWS.setParams(JSON.parse(value));\n\n\treturn JSON.stringify(AWS.listInstances());\n}\ncatch (error) {\n\terror += (String(error).endsWith('.')) ? '' : '.';\n\tZabbix.log(3, '[ AWS RDS ] ERROR: ' + error);\n\treturn JSON.stringify({ 'error': error });\n}",
                        "filter": {
                            "evaltype": "AND",
                            "conditions": [
                                {
                                    "macro": "{#AWS.RDS.INSTANCE.ID}",
                                    "value": "{$AWS.RDS.LLD.FILTER.NAME.MATCHES}",
                                    "formulaid": "A"
                                },
                                {
                                    "macro": "{#AWS.RDS.INSTANCE.ID}",
                                    "value": "{$AWS.RDS.LLD.FILTER.NAME.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "B"
                                },
                                {
                                    "macro": "{#AWS.RDS.REGION}",
                                    "value": "{$AWS.RDS.LLD.FILTER.REGION.MATCHES}",
                                    "formulaid": "C"
                                },
                                {
                                    "macro": "{#AWS.RDS.REGION}",
                                    "value": "{$AWS.RDS.LLD.FILTER.REGION.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "D"
                                }
                            ]
                        },
                        "description": "Get RDS instances.",
                        "host_prototypes": [
                            {
                                "uuid": "799663c52a644f78aa3b3c14d4cc7235",
                                "host": "{#AWS.RDS.INSTANCE.ID}",
                                "name": "{#AWS.RDS.INSTANCE.ID}",
                                "group_links": [
                                    {
                                        "group": {
                                            "name": "Databases"
                                        }
                                    }
                                ],
                                "templates": [
                                    {
                                        "name": "AWS RDS instance by HTTP"
                                    }
                                ],
                                "macros": [
                                    {
                                        "macro": "{$AWS.RDS.INSTANCE.ID}",
                                        "value": "{#AWS.RDS.INSTANCE.ID}",
                                        "description": "RDS instance ID."
                                    },
                                    {
                                        "macro": "{$AWS.REGION}",
                                        "value": "{#AWS.RDS.REGION}",
                                        "description": "RDS instance region."
                                    }
                                ],
                                "tags": [
                                    {
                                        "tag": "name",
                                        "value": "{#AWS.RDS.INSTANCE.ID}"
                                    },
                                    {
                                        "tag": "region",
                                        "value": "{#AWS.RDS.REGION}"
                                    },
                                    {
                                        "tag": "service",
                                        "value": "rds"
                                    }
                                ],
                                "custom_interfaces": "YES",
                                "interfaces": [
                                    {
                                        "ip": "{#AWS.RDS.INSTANCE.ID}"
                                    }
                                ]
                            }
                        ],
                        "timeout": "{$AWS.DATA.TIMEOUT}",
                        "parameters": [
                            {
                                "name": "AccessKeyId",
                                "value": "{$AWS.ACCESS.KEY.ID}"
                            },
                            {
                                "name": "auth_type",
                                "value": "{$AWS.AUTH_TYPE}"
                            },
                            {
                                "name": "proxy",
                                "value": "{$AWS.PROXY}"
                            },
                            {
                                "name": "region_match",
                                "value": "{$AWS.RDS.LLD.FILTER.REGION.MATCHES}"
                            },
                            {
                                "name": "region_not_match",
                                "value": "{$AWS.RDS.LLD.FILTER.REGION.NOT_MATCHES}"
                            },
                            {
                                "name": "SecretAccessKey",
                                "value": "{$AWS.SECRET.ACCESS.KEY}"
                            }
                        ],
                        "lld_macro_paths": [
                            {
                                "lld_macro": "{#AWS.RDS.INSTANCE.ID}",
                                "path": "$.DBInstanceIdentifier"
                            },
                            {
                                "lld_macro": "{#AWS.RDS.REGION}",
                                "path": "$.instanceRegion"
                            }
                        ]
                    },
                    {
                        "uuid": "ab6a97a108fb4dbc9fd1e07378721ffe",
                        "name": "S3 buckets discovery",
                        "type": "SCRIPT",
                        "key": "aws.s3.discovery",
                        "delay": "12h",
                        "params": "var AWS = {\n\tparams: {},\n\tmetadata: 'http://169.254.169.254/latest/meta-data/iam/security-credentials',\n\n\tgetField: function (data, path) {\n\t\tvar steps = path.split('.');\n\t\tfor (var i = 0; i < steps.length; i++) {\n\t\t\tvar step = steps[i];\n\t\t\tif (typeof data !== 'object' || typeof data[step] === 'undefined') {\n\t\t\t\tthrow 'Required field was not found: ' + path;\n\t\t\t}\n\n\t\t\tdata = data[step];\n\t\t}\n\n\t\treturn data;\n\t},\n\n\tsetParams: function (params) {\n\t\tAWS.params['proxy'] = params.proxy;\n\t\tswitch (AWS.getField(params, 'auth_type')) {\n\t\t\tcase 'role_base':\n\t\t\t\tAWS.params['auth_type'] = 'role_base';\n\t\t\t\tvar request = new HttpRequest();\n\t\t\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t\t\t}\n\t\t\t\tvar IamRoleName = request.get(AWS.metadata);\n\n\t\t\t\tif (request.getStatus() !== 200 || IamRoleName === null || IamRoleName === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata. Role not found.';\n\t\t\t\t}\n\n\t\t\t\tcredentials = request.get(AWS.metadata + '/' + encodeURI(IamRoleName));\n\n\t\t\t\tif (request.getStatus() !== 200 || credentials === null || credentials === '') {\n\t\t\t\t\tthrow 'Error getting security credentials from instance metadata.';\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcredentials = JSON.parse(credentials);\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\tthrow 'Failed to parse response received from instance metadata. Check debug log for more information.';\n\t\t\t\t}\n\n\t\t\t\t['AccessKeyId', 'SecretAccessKey', 'Token'].forEach(function (field) {\n\t\t\t\t\tif (typeof credentials !== 'object' || typeof credentials[field] === 'undefined' || credentials[field] === '') {\n\t\t\t\t\t\tthrow 'Required credentials is not set: \"' + field + '\".';\n\t\t\t\t\t};\n\t\t\t\t\tAWS.params[field] = credentials[field];\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'access_key':\n\t\t\tdefault:\n\t\t\t\tAWS.params['auth_type'] = 'access_key';\n\t\t\t\t['AccessKeyId', 'SecretAccessKey'].forEach(function (field) {\n\t\t\t\t\tif (typeof params !== 'object' || typeof params[field] === 'undefined' || params[field] === '') {\n\t\t\t\t\t\tthrow 'Required param is not set: \"' + field + '\".';\n\t\t\t\t\t}\n\t\t\t\t\tAWS.params[field] = params[field];\n\t\t\t\t});\n\t\t}\n\t},\n\n\tsign: function (key, message) {\n\t\tvar hex = hmac('sha256', key, message);\n\n\t\tif ((hex.length % 2) === 1) {\n\t\t\tthrow 'Invalid length of a hex string!';\n\t\t}\n\n\t\tvar result = new Int8Array(hex.length / 2);\n\t\tfor (var i = 0, b = 0; i < hex.length; i += 2, b++) {\n\t\t\tresult[b] = parseInt(hex.substring(i, i + 2), 16);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tprepareParams: function (params) {\n\t\tvar result = [];\n\n\t\tObject.keys(params).sort().forEach(function (key) {\n\t\t\tif (typeof params[key] !== 'object') {\n\t\t\t\tresult.push(key + '=' + encodeURIComponent(params[key]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult.push(prepareObject(key, params[key]));\n\t\t\t}\n\t\t});\n\n\t\treturn result.join('&');\n\t},\n\n\trequest: function (method, region, service, host, params, data, uri) {\n\t\tif (typeof data === 'undefined' || data === null) {\n\t\t\tdata = '';\n\t\t}\n\n\t\tvar amzdate = (new Date()).toISOString().replace(/\\.\\d+Z/, 'Z').replace(/[-:]/g, ''),\n\t\t\tdate = amzdate.replace(/T\\d+Z/, ''),\n\n\t\t\tcanonical_uri = '/' + uri;\n\n\t\tif (AWS.params.auth_type === 'role_base') {\n\t\t\tvar canonical_headers = 'content-encoding:amz-1.0\\n' + 'host:' + host + '\\n' + 'x-amz-date:' + amzdate + '\\n' + 'x-amz-security-token:' + AWS.params.Token + '\\n',\n\t\t\t\tsigned_headers = 'content-encoding;host;x-amz-date;x-amz-security-token';\n\t\t} else {\n\t\t\tvar canonical_headers = 'content-encoding:amz-1.0\\n' + 'host:' + host + '\\n' + 'x-amz-date:' + amzdate + '\\n',\n\t\t\t\tsigned_headers = 'content-encoding;host;x-amz-date';\n\t\t}\n\n\t\tvar canonical_request = method + '\\n' + canonical_uri + '\\n' + params + '\\n' + canonical_headers + '\\n' + signed_headers + '\\n' + sha256(data),\n\t\t\tcredential_scope = date + '/' + region + '/' + service + '/' + 'aws4_request',\n\t\t\trequest_string = 'AWS4-HMAC-SHA256' + '\\n' + amzdate + '\\n' + credential_scope + '\\n' + sha256(canonical_request),\n\t\t\tkey = AWS.sign('AWS4' + AWS.params.SecretAccessKey, date);\n\n\t\tkey = AWS.sign(key, region);\n\t\tkey = AWS.sign(key, service);\n\t\tkey = AWS.sign(key, 'aws4_request');\n\n\t\tvar request = new HttpRequest(),\n\t\t\turl = 'https://' + host + canonical_uri + '?' + params;\n\n\t\tif (typeof AWS.params.proxy !== 'undefined' && AWS.params.proxy !== '') {\n\t\t\trequest.setProxy(AWS.params.proxy);\n\t\t}\n\t\trequest.addHeader('x-amz-date: ' + amzdate);\n\t\trequest.addHeader('x-amz-content-sha256:' + sha256(data));\n\t\trequest.addHeader('Accept: application/json');\n\t\trequest.addHeader('Content-Type: application/json');\n\t\trequest.addHeader('Content-Encoding: amz-1.0');\n\t\trequest.addHeader('Authorization: ' + 'AWS4-HMAC-SHA256 Credential=' + AWS.params.AccessKeyId + '/' + credential_scope + ', ' + 'SignedHeaders=' + signed_headers + ', ' + 'Signature=' + hmac('sha256', key, request_string));\n\t\tif (AWS.params.auth_type === 'role_base')\n\t\t\trequest.addHeader('X-Amz-Security-Token: ' + AWS.params.Token);\n\n\t\tZabbix.log(4, '[ AWS S3 ] Sending request: ' + url);\n\n\t\tresponse = request.get(url);\n\n\t\tZabbix.log(4, '[ AWS S3 ] Received response with status code ' + request.getStatus() + ': ' + response);\n\n\t\tif (request.getStatus() !== 200) {\n\t\t\tthrow 'Request failed with status code ' + request.getStatus() + ': ' + response;\n\t\t}\n\t\tif (response !== null) {\n\t\t\ttry {\n\t\t\t\tresponse = XML.toJson(response);\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tthrow 'Failed to parse response received from AWS CloudWatch API. Check debug log for more information.';\n\t\t\t}\n\t\t}\n\n\t\treturn JSON.parse(response);\n\t},\n\n\tlistBuckets: function () {\n\t\tvar payload = {\n\t\t\t'Action': 'ListBuckets',\n\t\t\t'Version': '2006-03-01'\n\t\t};\n\n\t\tvar result = AWS.getField(AWS.request('GET', 'us-east-1', 's3', 's3.us-east-1.amazonaws.com', AWS.prepareParams(payload), '', ''), 'ListAllMyBucketsResult.Buckets.Bucket');\n\n\t\tif (result === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn Array.isArray(result) ? result : [result];\n\n\t}\n\n};\n\ntry {\n\tAWS.setParams(JSON.parse(value));\n\n\treturn JSON.stringify(AWS.listBuckets());\n}\ncatch (error) {\n\terror += (String(error).endsWith('.')) ? '' : '.';\n\tZabbix.log(3, '[ AWS S3 ] ERROR: ' + error);\n\treturn JSON.stringify({ 'error': error });\n}",
                        "filter": {
                            "evaltype": "AND",
                            "conditions": [
                                {
                                    "macro": "{#AWS.S3.NAME}",
                                    "value": "{$AWS.S3.LLD.FILTER.NAME.MATCHES}",
                                    "formulaid": "A"
                                },
                                {
                                    "macro": "{#AWS.S3.NAME}",
                                    "value": "{$AWS.S3.LLD.FILTER.NAME.NOT_MATCHES}",
                                    "operator": "NOT_MATCHES_REGEX",
                                    "formulaid": "B"
                                }
                            ]
                        },
                        "description": "Get S3 bucket instances.",
                        "host_prototypes": [
                            {
                                "uuid": "e45bd9810ea14718b17b875aad3fc544",
                                "host": "{#AWS.S3.NAME}",
                                "name": "{#AWS.S3.NAME}",
                                "group_links": [
                                    {
                                        "group": {
                                            "name": "Applications"
                                        }
                                    }
                                ],
                                "group_prototypes": [
                                    {
                                        "name": "{#AWS.S3.REGION}"
                                    }
                                ],
                                "templates": [
                                    {
                                        "name": "AWS S3 bucket by HTTP"
                                    }
                                ],
                                "macros": [
                                    {
                                        "macro": "{$AWS.S3.BUCKET.NAME}",
                                        "value": "{#AWS.S3.NAME}",
                                        "description": "S3 bucket name."
                                    },
                                    {
                                        "macro": "{$AWS.S3.FILTER.ID}",
                                        "value": "1",
                                        "description": "S3 bucket requests filter identifier."
                                    }
                                ],
                                "tags": [
                                    {
                                        "tag": "name",
                                        "value": "{#AWS.S3.NAME}"
                                    },
                                    {
                                        "tag": "service",
                                        "value": "s3"
                                    }
                                ],
                                "custom_interfaces": "YES",
                                "interfaces": [
                                    {
                                        "ip": "{#AWS.S3.NAME}"
                                    }
                                ]
                            }
                        ],
                        "timeout": "{$AWS.DATA.TIMEOUT}",
                        "parameters": [
                            {
                                "name": "AccessKeyId",
                                "value": "{$AWS.ACCESS.KEY.ID}"
                            },
                            {
                                "name": "auth_type",
                                "value": "{$AWS.AUTH_TYPE}"
                            },
                            {
                                "name": "proxy",
                                "value": "{$AWS.PROXY}"
                            },
                            {
                                "name": "SecretAccessKey",
                                "value": "{$AWS.SECRET.ACCESS.KEY}"
                            }
                        ],
                        "lld_macro_paths": [
                            {
                                "lld_macro": "{#AWS.S3.NAME}",
                                "path": "$.Name"
                            }
                        ]
                    }
                ],
                "tags": [
                    {
                        "tag": "class",
                        "value": "software"
                    },
                    {
                        "tag": "target",
                        "value": "aws"
                    }
                ],
                "macros": [
                    {
                        "macro": "{$AWS.ACCESS.KEY.ID}",
                        "description": "Access key ID."
                    },
                    {
                        "macro": "{$AWS.AUTH_TYPE}",
                        "value": "access_key",
                        "description": "Authorization method. Possible values: role_base, access_key."
                    },
                    {
                        "macro": "{$AWS.DATA.TIMEOUT}",
                        "value": "60s",
                        "description": "A response timeout for an API."
                    },
                    {
                        "macro": "{$AWS.EC2.LLD.FILTER.NAME.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable EC2 instances by namespace."
                    },
                    {
                        "macro": "{$AWS.EC2.LLD.FILTER.NAME.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered EC2 instances by namespace."
                    },
                    {
                        "macro": "{$AWS.EC2.LLD.FILTER.REGION.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable EC2 instances by region."
                    },
                    {
                        "macro": "{$AWS.EC2.LLD.FILTER.REGION.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered EC2 instances by region."
                    },
                    {
                        "macro": "{$AWS.ECS.LLD.FILTER.NAME.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable ECS clusters by name."
                    },
                    {
                        "macro": "{$AWS.ECS.LLD.FILTER.NAME.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered ECS clusters by name."
                    },
                    {
                        "macro": "{$AWS.ECS.LLD.FILTER.REGION.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable ECS clusters by region."
                    },
                    {
                        "macro": "{$AWS.ECS.LLD.FILTER.REGION.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered ECS clusters by region."
                    },
                    {
                        "macro": "{$AWS.ECS.LLD.FILTER.STATUS.MATCHES}",
                        "value": "ACTIVE",
                        "description": "Filter of discoverable ECS clusters by status."
                    },
                    {
                        "macro": "{$AWS.ECS.LLD.FILTER.STATUS.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered ECS clusters by status."
                    },
                    {
                        "macro": "{$AWS.ELB.LLD.FILTER.NAME.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable ELB load balancer by name."
                    },
                    {
                        "macro": "{$AWS.ELB.LLD.FILTER.NAME.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered ELB load balancer by name."
                    },
                    {
                        "macro": "{$AWS.ELB.LLD.FILTER.REGION.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable ELB load balancer by region."
                    },
                    {
                        "macro": "{$AWS.ELB.LLD.FILTER.REGION.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered ELB load balancer by region."
                    },
                    {
                        "macro": "{$AWS.ELB.LLD.FILTER.STATE.MATCHES}",
                        "value": "active",
                        "description": "Filter of discoverable ELB load balancer by status."
                    },
                    {
                        "macro": "{$AWS.ELB.LLD.FILTER.STATE.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered ELB load balancer by status."
                    },
                    {
                        "macro": "{$AWS.PROXY}",
                        "description": "Sets HTTP proxy value. If this macro is empty then no proxy is used."
                    },
                    {
                        "macro": "{$AWS.RDS.LLD.FILTER.NAME.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable RDS instances by namespace."
                    },
                    {
                        "macro": "{$AWS.RDS.LLD.FILTER.NAME.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered RDS instances by namespace."
                    },
                    {
                        "macro": "{$AWS.RDS.LLD.FILTER.REGION.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable RDS instances by region."
                    },
                    {
                        "macro": "{$AWS.RDS.LLD.FILTER.REGION.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered RDS instances by region."
                    },
                    {
                        "macro": "{$AWS.S3.LLD.FILTER.NAME.MATCHES}",
                        "value": ".*",
                        "description": "Filter of discoverable S3 buckets by namespace."
                    },
                    {
                        "macro": "{$AWS.S3.LLD.FILTER.NAME.NOT_MATCHES}",
                        "value": "CHANGE_IF_NEEDED",
                        "description": "Filter to exclude discovered S3 buckets by namespace."
                    },
                    {
                        "macro": "{$AWS.SECRET.ACCESS.KEY}",
                        "type": "SECRET_TEXT",
                        "description": "Secret access key."
                    }
                ]
            }
        ]
    }
}