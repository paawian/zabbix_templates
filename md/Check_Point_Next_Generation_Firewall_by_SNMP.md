# Check Point Next Generation Firewall by SNMP template description

The template for monitoring Check Point Quantum Next Generation Firewall Security Gateway by SNMP.

MIBs used:
HOST-RESOURCES-MIB
CHECKPOINT-MIB
UCD-SNMP-MIB
SNMPv2-MIB
IF-MIB

Generated by official Zabbix template tool "Templator"

## Summary
* [items](#items)
* [macros](#macros)
* [triggers](#triggers)
* [discoveries](#discoveries)
  * [Discovery CPU discovery ](#discovery_cpu_discovery)
  * [Discovery FAN discovery ](#discovery_fan_discovery)
  * [Discovery Firewall discovery ](#discovery_firewall_discovery)
  * [Discovery Network interfaces discovery ](#discovery_network_interfaces_discovery)
  * [Discovery PSU discovery ](#discovery_psu_discovery)
  * [Discovery Software blades discovery ](#discovery_software_blades_discovery)
  * [Discovery Temperature discovery ](#discovery_temperature_discovery)
  * [Discovery Storage discovery ](#discovery_storage_discovery)
  * [Discovery Voltage discovery ](#discovery_voltage_discovery)
  * [Discovery VPN discovery ](#discovery_vpn_discovery)

<a name="items"></a>

## Items
| name | description | key | type | delay |
| ------------- |------------- |------------- |------------- |------------- |
| ICMP ping | Host accessibility by ICMP.<br>0 - ICMP ping fails.<br>1 - ICMP ping successful. | icmpping | SIMPLE | no delay |
| ICMP loss | Percentage of lost packets. | icmppingloss | SIMPLE | no delay |
| ICMP response time | ICMP ping response time (in seconds). | icmppingsec | SIMPLE | no delay |
| SNMP walk network interfaces | Used for discovering interfaces from IF-MIB. | net.if.walk | SNMP_AGENT | no delay |
| Remote Access users | MIB: CHECKPOINT-MIB<br>Number of remote access users. | remote.users.number | SNMP_AGENT | no delay |
| SNMP walk fan sensors | Used for discovering fan sensors from CHECKPOINT-MIB. | sensor.fan.walk | SNMP_AGENT | no delay |
| SNMP walk PSU sensors | Used for discovering power supply sensors from CHECKPOINT-MIB. | sensor.psu.walk | SNMP_AGENT | no delay |
| SNMP walk temperature sensors | Used for discovering temperature sensors from CHECKPOINT-MIB. | sensor.temp.walk | SNMP_AGENT | no delay |
| SNMP walk voltage sensors | Used for discovering voltage sensors from CHECKPOINT-MIB. | sensor.volt.walk | SNMP_AGENT | no delay |
| SNMP traps (fallback) | Used to collect all SNMP traps unmatched by other `snmptrap` items. | snmptrap.fallback | SNMP_TRAP | 0 |
| SNMP walk svn features | Used for discovering software blades and features from CHECKPOINT-MIB. | svn.feature.walk | SNMP_AGENT | no delay |
| System contact details | MIB: SNMPv2-MIB<br>Name and contact information of the contact person for the node. If not provided, the value is a zero-length string. | system.contact | SNMP_AGENT | 15m |
| CPU idle time | MIB: CHECKPOINT-MIB<br>Average time the CPU has spent doing nothing. | system.cpu.idle | SNMP_AGENT | no delay |
| CPU interrupts per second | MIB: CHECKPOINT-MIB<br>Number of interrupts processed per second. | system.cpu.intr | SNMP_AGENT | no delay |
| Load average (1m avg) | MIB: UCD-SNMP-MIB<br>Average number of processes being executed or waiting over the last minute. | system.cpu.load.avg1 | SNMP_AGENT | no delay |
| Load average (5m avg) | MIB: UCD-SNMP-MIB<br>Average number of processes being executed or waiting over the last 5 minutes. | system.cpu.load.avg5 | SNMP_AGENT | no delay |
| Load average (15m avg) | MIB: UCD-SNMP-MIB<br>Average number of processes being executed or waiting over the last 15 minutes. | system.cpu.load.avg15 | SNMP_AGENT | no delay |
| Number of CPUs | MIB: CHECKPOINT-MIB<br>Number of processors. | system.cpu.num | SNMP_AGENT | no delay |
| Context switches per second | MIB: UCD-SNMP-MIB<br>Number of context switches per second. | system.cpu.switches | SNMP_AGENT | no delay |
| CPU system time | MIB: CHECKPOINT-MIB<br>Average time the CPU has spent running the kernel and its processes. | system.cpu.system | SNMP_AGENT | no delay |
| CPU user time | MIB: CHECKPOINT-MIB<br>Average time the CPU has spent running user processes that are not niced. | system.cpu.user | SNMP_AGENT | no delay |
| CPU utilization | MIB: CHECKPOINT-MIB<br>CPU utilization per core in %. | system.cpu.util | SNMP_AGENT | no delay |
| SNMP walk CPU | Used for discovering CPU from CHECKPOINT-MIB. | system.cpu.walk | SNMP_AGENT | no delay |
| System description | MIB: SNMPv2-MIB<br>Full name and version identification of the system's hardware type, software operating system, and networking software. | system.descr | SNMP_AGENT | 15m |
| Appliance manufacturer | MIB: CHECKPOINT-MIB<br>Appliance manufacturer. | system.hw.manufacturer | SNMP_AGENT | 1h |
| Appliance product name | MIB: CHECKPOINT-MIB<br>Appliance product name. | system.hw.model | SNMP_AGENT | 1h |
| Appliance serial number | MIB: CHECKPOINT-MIB<br>Appliance serial number. | system.hw.serialnumber | SNMP_AGENT | 1h |
| System location | MIB: SNMPv2-MIB<br>Physical location of the node (e.g., `equipment room`, `3rd floor`). If not provided, the value is a zero-length string. | system.location | SNMP_AGENT | 15m |
| System name | MIB: SNMPv2-MIB<br>An administratively-assigned name for the node (the node's fully-qualified domain name). If not provided, the value is a zero-length string. | system.name | SNMP_AGENT | 15m |
| System object ID | MIB: SNMPv2-MIB<br>The vendor's authoritative identification of the entity as part of the vendor's SMI enterprises subtree with the prefix 1.3.6.1.4.1 (e.g., a vendor with the identifier 1.3.6.1.4.1.4242 might assign a system object with the OID 1.3.6.1.4.1.4242.1.1). | system.objectid | SNMP_AGENT | 15m |
| System uptime | MIB: HOST-RESOURCES-V2-MIB<br>Time since the network management portion of the system was last re-initialized. | system.uptime | SNMP_AGENT | no delay |
| SNMP walk disks | Used for discovering storage disks from CHECKPOINT-MIB. | vfs.fs.walk | SNMP_AGENT | no delay |
| Active memory | MIB: CHECKPOINT-MIB<br>Active real memory (memory used by applications that is not cached to the disk) in bytes. | vm.memory.active | SNMP_AGENT | no delay |
| Free memory | MIB: CHECKPOINT-MIB<br>Free memory available for applications in bytes. | vm.memory.free | SNMP_AGENT | no delay |
| Total memory | MIB: CHECKPOINT-MIB<br>Total real memory in bytes. Memory used by applications. | vm.memory.total | SNMP_AGENT | no delay |
| Used memory | Used real memory calculated by total real memory and free real memory in bytes. | vm.memory.used | CALCULATED | no delay |
| Memory utilization | Memory utilization in %. | vm.memory.util | CALCULATED | no delay |
| Decrypted packets per second | MIB: CHECKPOINT-MIB<br>Number of decrypted packets per second. | vpn.packets.decrypted | SNMP_AGENT | no delay |
| Encrypted packets per second | MIB: CHECKPOINT-MIB<br>Number of encrypted packets per second. | vpn.packets.encrypted | SNMP_AGENT | no delay |
| SNMP walk VPN tunnels | Used for discovering VPN tunnels from CHECKPOINT-MIB. | vpn.tunnel.walk | SNMP_AGENT | no delay |
| SNMP agent availability | Availability of SNMP checks on the host. The value of this item corresponds to the availability icons in the host list.<br><br>Possible values:<br>0 - not available<br>1 - available<br>2 - unknown | zabbix[host,snmp,available] | INTERNAL | no delay |


<a name="macros"></a>

## Macros
| macro | value |
| ------------- |------------- |
| {$CPU.UTIL.CRIT} | 90 |
| {$DISK.FREE.MIN.CRIT} | 5G |
| {$DISK.FREE.MIN.WARN} | 10G |
| {$DISK.NAME.MATCHES} | .+ |
| {$DISK.NAME.NOT_MATCHES} | ^(/dev\|/sys\|/run\|/proc\|.+/shm$) |
| {$DISK.PUSED.MAX.CRIT} | 90 |
| {$DISK.PUSED.MAX.WARN} | 80 |
| {$FW.DROPPED.PACKETS.TH} | 0 |
| {$ICMP_LOSS_WARN} | 20 |
| {$ICMP_RESPONSE_TIME_WARN} | 0.15 |
| {$LICENSE.CONTROL} | 1 |
| {$LICENSE.EXPIRY.WARN} | 7 |
| {$LOAD_AVG_PER_CPU.MAX.WARN} | 1.5 |
| {$MEMORY.UTIL.MAX} | 90 |
| {$NET.IF.CONTROL} | 1 |
| {$NET.IF.ERRORS.WARN} | 2 |
| {$NET.IF.IFADMINSTATUS.MATCHES} | .* |
| {$NET.IF.IFADMINSTATUS.NOT_MATCHES} | ^2$ |
| {$NET.IF.IFALIAS.MATCHES} | .* |
| {$NET.IF.IFALIAS.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$NET.IF.IFDESCR.MATCHES} | .* |
| {$NET.IF.IFDESCR.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$NET.IF.IFNAME.MATCHES} | .* |
| {$NET.IF.IFNAME.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$NET.IF.IFOPERSTATUS.MATCHES} | .* |
| {$NET.IF.IFOPERSTATUS.NOT_MATCHES} | ^6$ |
| {$NET.IF.IFTYPE.MATCHES} | .* |
| {$NET.IF.IFTYPE.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$NET.IF.UTIL.MAX} | 95 |
| {$SNMP.TIMEOUT} | 5m |
| {$SW.NAME.MATCHES} | .* |
| {$SW.NAME.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$TEMP.NAME.MATCHES} | .* |
| {$TEMP.NAME.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$TEMP.VALUE.CRIT} | 75 |
| {$TEMP.VALUE.LOW} | 5 |
| {$TEMP.VALUE.WARN} | 65 |
| {$VOLT.NAME.MATCHES} | .* |
| {$VOLT.NAME.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$VPN.NAME.MATCHES} | .* |
| {$VPN.NAME.NOT_MATCHES} | CHANGE_IF_NEEDED |
| {$VPN.STATE.CONTROL} | 1 |


<a name="triggers"></a>

## Triggers
| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| Unavailable by ICMP ping | HIGH | Last three attempts returned timeout. Please check device connectivity. | max(/Check Point Next Generation Firewall by SNMP/icmpping,#3)=0 | [{"tag": "scope", "value": "availability"}] | no url |
| High ICMP ping loss | WARNING | ICMP packet loss detected. | min(/Check Point Next Generation Firewall by SNMP/icmppingloss,5m)>{$ICMP_LOSS_WARN} and min(/Check Point Next Generation Firewall by SNMP/icmppingloss,5m)<100 | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |
| High ICMP ping response time | WARNING | Average ICMP response time is too high. | avg(/Check Point Next Generation Firewall by SNMP/icmppingsec,5m)>{$ICMP_RESPONSE_TIME_WARN} | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |
| High CPU utilization | WARNING | CPU utilization is too high. The system might be slow to respond. | min(/Check Point Next Generation Firewall by SNMP/system.cpu.util,5m)>{$CPU.UTIL.CRIT} | [{"tag": "scope", "value": "performance"}] | no url |
| Device has been replaced | INFO | The device serial number has changed. Acknowledge to close the problem manually. | last(/Check Point Next Generation Firewall by SNMP/system.hw.serialnumber,#1)<>last(/Check Point Next Generation Firewall by SNMP/system.hw.serialnumber,#2) and<br>length(last(/Check Point Next Generation Firewall by SNMP/system.hw.serialnumber))>0 | [{"tag": "scope", "value": "notice"}] | no url |
| System name has changed | INFO | The name of the system has changed. Acknowledge to close the problem manually. | last(/Check Point Next Generation Firewall by SNMP/system.name,#1)<>last(/Check Point Next Generation Firewall by SNMP/system.name,#2) and length(last(/Check Point Next Generation Firewall by SNMP/system.name))>0 | [{"tag": "scope", "value": "notice"}, {"tag": "scope", "value": "security"}] | no url |
| Device has been restarted | INFO | Uptime is less than 10 minutes. | last(/Check Point Next Generation Firewall by SNMP/system.uptime)<10m | [{"tag": "scope", "value": "notice"}] | no url |
| High memory utilization | AVERAGE | The system is running out of free memory. | min(/Check Point Next Generation Firewall by SNMP/vm.memory.util,5m)>{$MEMORY.UTIL.MAX} | [{"tag": "scope", "value": "capacity"}, {"tag": "scope", "value": "performance"}] | no url |
| No SNMP data collection | WARNING | SNMP is not available for polling. Please check device connectivity and SNMP settings. | max(/Check Point Next Generation Firewall by SNMP/zabbix[host,snmp,available],{$SNMP.TIMEOUT})=0 | [{"tag": "scope", "value": "availability"}] | no url |
| Load average is too high | AVERAGE | The load average per CPU is too high. The system may be slow to respond. | min(/Check Point Next Generation Firewall by SNMP/system.cpu.load.avg1,5m)/last(/Check Point Next Generation Firewall by SNMP/system.cpu.num)>{$LOAD_AVG_PER_CPU.MAX.WARN}<br>and last(/Check Point Next Generation Firewall by SNMP/system.cpu.load.avg5)>0<br>and last(/Check Point Next Generation Firewall by SNMP/system.cpu.load.avg15)>0 | [{"tag": "scope", "value": "capacity"}, {"tag": "scope", "value": "performance"}] | no url |


<a name="discoveries"></a>

## Discoveries
| name | key | description | type | lifetime | delay |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| CPU discovery | cpu.discovery | For discovering CPU from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |
| FAN discovery | fan.discovery | For discovering fan sensors from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |
| Firewall discovery | fw.discovery | This discovery will create a set of firewall metrics from CHECKPOINT-MIB if the firewall is installed. | SNMP_AGENT | no lifetime | 1h |
| Network interfaces discovery | net.if.discovery | For discovering interfaces from IF-MIB. | DEPENDENT | no lifetime | 0 |
| PSU discovery | psu.discovery | For discovering power supply sensors from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |
| Software blades discovery | svn.sw.discovery | For discovering software blades and features from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |
| Temperature discovery | temperature.discovery | For discovering temperature sensors from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |
| Storage discovery | vfs.fs.discovery | For discovering storage disks from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |
| Voltage discovery | voltage.discovery | For discovering voltage sensors from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |
| VPN discovery | vpn.discovery | For discovering VPN tunnels from CHECKPOINT-MIB. | DEPENDENT | no lifetime | 0 |


<a name="discovery_cpu_discovery"></a>

## Discovery CPU discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| CPU Core {#CPU.ID}: CPU idle time | MIB: CHECKPOINT-MIB<br>The time the CPU `{#CPU.ID}` has spent doing nothing. | system.core.idle[multiProcIdleTime.{#CPU.ID}] | DEPENDENT |
| CPU Core {#CPU.ID}: CPU system time | MIB: CHECKPOINT-MIB<br>The time the CPU `{#CPU.ID}` has spent running the kernel and its processes. | system.core.system[multiProcSystemTime.{#CPU.ID}] | DEPENDENT |
| CPU Core {#CPU.ID}: CPU user time | MIB: CHECKPOINT-MIB<br>The time the CPU `{#CPU.ID}` has spent running user processes that are not niced. | system.core.user[multiProcUserTime.{#CPU.ID}] | DEPENDENT |
| CPU Core {#CPU.ID}: CPU utilization | MIB: CHECKPOINT-MIB<br>CPU `{#CPU.ID}` utilization in %. | system.core.util[multiProcUsage.{#CPU.ID}] | DEPENDENT |


<a name="discovery_fan_discovery"></a>

## Discovery FAN discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| FAN {#SNMPINDEX}: Fan speed | MIB: CHECKPOINT-MIB<br>Current speed of the fan. | sensor.fan.speed[fanSpeedSensorValue.{#SNMPINDEX}] | DEPENDENT |
| FAN {#SNMPINDEX}: Fan status | MIB: CHECKPOINT-MIB<br>Current status of the fan tray. | sensor.fan.status[fanSpeedSensorStatus.{#SNMPINDEX}] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| FAN {#SNMPINDEX}: Fan speed is out of range | AVERAGE | Please check the fan unit. | count(/Check Point Next Generation Firewall by SNMP/sensor.fan.status[fanSpeedSensorStatus.{#SNMPINDEX}],#3,"eq",1)=3 | [{"tag": "scope", "value": "performance"}] | no url |


<a name="discovery_firewall_discovery"></a>

## Discovery Firewall discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| Check Point Firewall: Accepted packets per second{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Number of accepted packets per second. | fw.accepted[fwAccepted.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Peak concurrent connections{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Peak number of concurrent connections since last reboot. | fw.conn.num.peak[fwPeakNumConn.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Concurrent connections{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Number of concurrent IPv6 and IPv4 connections. | fw.conn.num[fwNumConn.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Dropped packets per second{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Number of dropped packets per second. | fw.dropped[fwDropped.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Firewall filter install time{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Last install time of the firewall filter. | fw.filter.installed[fwFilterDate.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Firewall filter name{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Name of the firewall filter. | fw.filter.name[fwFilterName.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Logged packets per second{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Number of logged packets per second. | fw.logged[fwLogged.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Rejected packets per second{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Number of rejected packets per second. | fw.rejected[fwRejected.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: SIC Trust State{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Firewall SIC Trust State. | fw.sic.trust.state[fwSICTrustState.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Utilized drops number per second{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Number of dropped packets per second due to instance being fully utilized. | fw.utilized.drops[fwFullyUtilizedDrops.{#SNMPINDEX}] | SNMP_AGENT |
| Check Point Firewall: Firewall version{#SINGLETON} | MIB: CHECKPOINT-MIB<br>Current version of the firewall. | fw.version[fwVersion.{#SNMPINDEX}] | SNMP_AGENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| Check Point Firewall: Instance is currently fully utilized | HIGH | This trigger uses the number of dropped packets, an increase of which indicates that the instance is fully utilized. | avg(/Check Point Next Generation Firewall by SNMP/fw.utilized.drops[fwFullyUtilizedDrops.{#SNMPINDEX}],5m)>{$FW.DROPPED.PACKETS.TH} | [{"tag": "scope", "value": "availability"}] | no url |


<a name="discovery_network_interfaces_discovery"></a>

## Discovery Network interfaces discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| Interface {#IFNAME}({#IFALIAS}): Inbound packets discarded | MIB: IF-MIB<br>The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.<br>Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of `ifCounterDiscontinuityTime`. | net.if.in.discards[ifInDiscards.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Inbound packets with errors | MIB: IF-MIB<br>For packet-oriented interfaces - the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.<br>For character-oriented or fixed-length interfaces - the number of inbound transmission units that contained errors preventing them from being deliverable to a higher-layer protocol.<br>Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of `ifCounterDiscontinuityTime`. | net.if.in.errors[ifInErrors.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Bits received | MIB: IF-MIB<br>The total number of octets received on the interface, including framing characters. This object is a 64-bit version of `ifInOctets`.<br>Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of `ifCounterDiscontinuityTime`. | net.if.in[ifInOctets.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Outbound packets discarded | MIB: IF-MIB<br>The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space.<br>Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of `ifCounterDiscontinuityTime`. | net.if.out.discards[ifOutDiscards.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Outbound packets with errors | MIB: IF-MIB<br>For packet-oriented interfaces - the number of outbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.<br>For character-oriented or fixed-length interfaces - the number of outbound transmission units that contained errors preventing them from being deliverable to a higher-layer protocol.<br>Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of `ifCounterDiscontinuityTime`. | net.if.out.errors[ifOutErrors.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Bits sent | MIB: IF-MIB<br>The total number of octets transmitted out of the interface, including framing characters. This object is a 64-bit version of `ifOutOctets`.<br>Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of `ifCounterDiscontinuityTime`. | net.if.out[ifOutOctets.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Speed | MIB: IF-MIB<br>An estimate of the interface's current bandwidth in units of 1,000,000 bits per second.<br>If this object reports a value of `n`, then the speed of the interface is somewhere in the range of `n-500,000` to `n+499,999`.<br>For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.<br>For a sub-layer which has no concept of bandwidth, this object should be zero. | net.if.speed[ifSpeed.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Operational status | MIB: IF-MIB<br>The current operational state of the interface.<br>- The `testing(3)` state indicates that no operational packets can be passed.<br>- If `ifAdminStatus` is `down(2)`, then `ifOperStatus` should be `down(2)`.<br>- If `ifAdminStatus` is changed to `up(1)`, then `ifOperStatus` should change to `up(1)` if the interface is ready to transmit and receive network traffic.<br>- It should change to `dormant(5)` if the interface is waiting for external actions (such as a serial line waiting for an incoming connection).<br>- It should remain in the `down(2)` state if and only if there is a fault that prevents it from going to the `up(1)` state.<br>- It should remain in the `notPresent(6)` state if the interface has missing (typically, hardware) components. | net.if.status[ifOperStatus.{#SNMPINDEX}] | DEPENDENT |
| Interface {#IFNAME}({#IFALIAS}): Interface type | MIB: IF-MIB<br>The type of interface.<br>Additional values for `ifType` are assigned by the Internet Assigned Numbers Authority (IANA) through updating the syntax of the IANAifType textual convention. | net.if.type[ifType.{#SNMPINDEX}] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| Interface {#IFNAME}({#IFALIAS}): Link down | AVERAGE | This trigger expression works as follows:<br>1. It can be triggered if the interface link status is down.<br>2. `{$NET.IF.CONTROL:"{#IFNAME}"}=1` - a user can redefine the context macro to "0", marking this interface as not important. No new trigger will be fired if this interface link is down.<br>3. `{TEMPLATE_NAME:METRIC.diff()}=1` - the trigger fires only if the interface link status was up to "1" sometime before.<br><br>WARNING: If closed manually, it will not fire again on the next poll because of `diff`. | {$NET.IF.CONTROL:"{#IFNAME}"}=1 and last(/Check Point Next Generation Firewall by SNMP/net.if.status[ifOperStatus.{#SNMPINDEX}])=1 and (last(/Check Point Next Generation Firewall by SNMP/net.if.status[ifOperStatus.{#SNMPINDEX}],#1)<>last(/Check Point Next Generation Firewall by SNMP/net.if.status[ifOperStatus.{#SNMPINDEX}],#2)) | [{"tag": "scope", "value": "availability"}] | no url |
| Interface {#IFNAME}({#IFALIAS}): Ethernet has changed to lower speed than it was before | INFO | This Ethernet connection has transitioned down from its known maximum speed. This might be a sign of autonegotiation issues. Acknowledge to close the problem manually. | change(/Check Point Next Generation Firewall by SNMP/net.if.speed[ifSpeed.{#SNMPINDEX}])<0 and last(/Check Point Next Generation Firewall by SNMP/net.if.speed[ifSpeed.{#SNMPINDEX}])>0<br>and (<br>last(/Check Point Next Generation Firewall by SNMP/net.if.type[ifType.{#SNMPINDEX}])=6 or<br>last(/Check Point Next Generation Firewall by SNMP/net.if.type[ifType.{#SNMPINDEX}])=7 or<br>last(/Check Point Next Generation Firewall by SNMP/net.if.type[ifType.{#SNMPINDEX}])=11 or<br>last(/Check Point Next Generation Firewall by SNMP/net.if.type[ifType.{#SNMPINDEX}])=62 or<br>last(/Check Point Next Generation Firewall by SNMP/net.if.type[ifType.{#SNMPINDEX}])=69 or<br>last(/Check Point Next Generation Firewall by SNMP/net.if.type[ifType.{#SNMPINDEX}])=117<br>)<br>and<br>(last(/Check Point Next Generation Firewall by SNMP/net.if.status[ifOperStatus.{#SNMPINDEX}])<>2) | [{"tag": "scope", "value": "performance"}] | no url |
| Interface {#IFNAME}({#IFALIAS}): High bandwidth usage | WARNING | The utilization of the network interface is close to its estimated maximum bandwidth. | (avg(/Check Point Next Generation Firewall by SNMP/net.if.in[ifInOctets.{#SNMPINDEX}],15m)>({$NET.IF.UTIL.MAX:"{#IFNAME}"}/100)*last(/Check Point Next Generation Firewall by SNMP/net.if.speed[ifSpeed.{#SNMPINDEX}]) or<br>avg(/Check Point Next Generation Firewall by SNMP/net.if.out[ifOutOctets.{#SNMPINDEX}],15m)>({$NET.IF.UTIL.MAX:"{#IFNAME}"}/100)*last(/Check Point Next Generation Firewall by SNMP/net.if.speed[ifSpeed.{#SNMPINDEX}])) and <br>last(/Check Point Next Generation Firewall by SNMP/net.if.speed[ifSpeed.{#SNMPINDEX}])>0 | [{"tag": "scope", "value": "performance"}] | no url |
| Interface {#IFNAME}({#IFALIAS}): High error rate | WARNING | It recovers when it is below 80% of the `{$NET.IF.ERRORS.WARN:"{#IFNAME}"}` threshold. | min(/Check Point Next Generation Firewall by SNMP/net.if.in.errors[ifInErrors.{#SNMPINDEX}],5m)>{$NET.IF.ERRORS.WARN:"{#IFNAME}"} or <br>min(/Check Point Next Generation Firewall by SNMP/net.if.out.errors[ifOutErrors.{#SNMPINDEX}],5m)>{$NET.IF.ERRORS.WARN:"{#IFNAME}"} | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |


<a name="discovery_psu_discovery"></a>

## Discovery PSU discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| PSU {#SNMPINDEX}: Power supply status | MIB: CHECKPOINT-MIB<br>Power supply status. | sensor.psu.status[powerSupplyStatus.{#SNMPINDEX}] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| PSU {#SNMPINDEX}: Power supply is in down state | AVERAGE | Please check the power supply unit for errors. | count(/Check Point Next Generation Firewall by SNMP/sensor.psu.status[powerSupplyStatus.{#SNMPINDEX}],#3,"eq",1)=3 | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |


<a name="discovery_software_blades_discovery"></a>

## Discovery Software blades discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| {#SW.NAME}: License expiration date | MIB: CHECKPOINT-MIB<br>Expiration date for the license of the software blade. Doesn't return a value if the license doesn't have an expiration date. | svn.sw.license.exp_date[licensingExpirationDate.{#SNMPINDEX}] | DEPENDENT |
| {#SW.NAME}: License total quota | MIB: CHECKPOINT-MIB<br>Total quota amount for the license of the software blade. | svn.sw.license.quota.total[licensingTotalQuota.{#SNMPINDEX}] | DEPENDENT |
| {#SW.NAME}: License used quota | MIB: CHECKPOINT-MIB<br>Used quota amount for the license of the software blade. | svn.sw.license.quota.used[licensingUsedQuota.{#SNMPINDEX}] | DEPENDENT |
| {#SW.NAME}: License state | MIB: CHECKPOINT-MIB<br>Current license state of the software blade. | svn.sw.license.state[licensingState.{#SNMPINDEX}] | DEPENDENT |
| {#SW.NAME}: Software blade status | MIB: CHECKPOINT-MIB<br>Current software blade status. | svn.sw.status[licensingBladeActive.{#SNMPINDEX}] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| {#SW.NAME}: License expires soon | WARNING | This trigger expression works as follows:<br>1. It can be triggered if the license expires soon.<br>2. `{$LICENSE.CONTROL:"{#SW.NAME}"}=1` - a user can redefine the context macro to "0", marking the current license as not important. No new trigger will be fired if this license expires. | {$LICENSE.CONTROL:"{#SW.NAME}"}=1 and (last(/Check Point Next Generation Firewall by SNMP/svn.sw.license.exp_date[licensingExpirationDate.{#SNMPINDEX}]) - now()) / 86400 < {$LICENSE.EXPIRY.WARN:"{#SW.NAME}"} and last(/Check Point Next Generation Firewall by SNMP/svn.sw.license.exp_date[licensingExpirationDate.{#SNMPINDEX}]) > now() | [{"tag": "scope", "value": "notice"}] | no url |
| {#SW.NAME}: License has been expired | AVERAGE | This trigger expression works as follows:<br>1. It can be triggered if the license has been expired.<br>2. `{$LICENSE.CONTROL:"{#SW.NAME}"}=1` - a user can redefine the context macro to "0", marking the current license as not important. No new trigger will be fired if this license is expired. | {$LICENSE.CONTROL:"{#SW.NAME}"}=1 and (last(/Check Point Next Generation Firewall by SNMP/svn.sw.license.exp_date[licensingExpirationDate.{#SNMPINDEX}]) - now()) / 86400 < now() | [{"tag": "scope", "value": "notice"}] | no url |


<a name="discovery_temperature_discovery"></a>

## Discovery Temperature discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| {#SENSOR.NAME}: Temperature | MIB: CHECKPOINT-MIB<br>Current temperature reading in degrees Celsius from the hardware component's temperature sensor. | sensor.temp.value[tempertureSensorValue.{#SNMPINDEX}] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| {#SENSOR.NAME}: Temperature is above critical threshold | HIGH | This trigger uses temperature sensor values. | avg(/Check Point Next Generation Firewall by SNMP/sensor.temp.value[tempertureSensorValue.{#SNMPINDEX}],5m)>{$TEMP.VALUE.CRIT:"{#SENSOR.NAME}"} | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |
| {#SENSOR.NAME}: Temperature is above warning threshold | WARNING | This trigger uses temperature sensor values. | avg(/Check Point Next Generation Firewall by SNMP/sensor.temp.value[tempertureSensorValue.{#SNMPINDEX}],5m)>{$TEMP.VALUE.WARN:"{#SENSOR.NAME}"} | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |
| {#SENSOR.NAME}: Temperature is too low | AVERAGE | This trigger uses temperature sensor values. | avg(/Check Point Next Generation Firewall by SNMP/sensor.temp.value[tempertureSensorValue.{#SNMPINDEX}],5m)<{$TEMP.VALUE.LOW:"{#SENSOR.NAME}"} | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |


<a name="discovery_storage_discovery"></a>

## Discovery Storage discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| {#DISK.NAME}: Available disk space | MIB: CHECKPOINT-MIB<br>Available free disk (not reserved by the OS) in bytes. | vfs.fs.avail[multiDiskFreeAvailableBytes.{#SNMPINDEX}] | DEPENDENT |
| {#DISK.NAME}: Free disk space | MIB: CHECKPOINT-MIB<br>Free disk capacity in bytes. | vfs.fs.free[multiDiskFreeTotalBytes.{#SNMPINDEX}] | DEPENDENT |
| {#DISK.NAME}: Disk space utilization | Space utilization calculated by the free percentage metric `multiDiskFreeTotalPercent`, expressed in % | vfs.fs.pused[multiDiskUsagePercent.{#SNMPINDEX}] | DEPENDENT |
| {#DISK.NAME}: Total disk space | MIB: CHECKPOINT-MIB<br>Total disk size in bytes. | vfs.fs.total[multiDiskSize.{#SNMPINDEX}] | DEPENDENT |
| {#DISK.NAME}: Used disk space | MIB: CHECKPOINT-MIB<br>Amount of disk used in bytes. | vfs.fs.used[multiDiskUsed.{#SNMPINDEX}] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| {#DISK.NAME}: Disk space is critically low | AVERAGE | Two conditions should match:<br>1. The first condition - utilization of the space should be above `{$DISK.PUSED.MAX.CRIT:"{#DISK.NAME}"}`.<br>2. The second condition should be one of the following:<br>- the disk free space is less than `{$DISK.FREE.MIN.CRIT:"{#DISK.NAME}"}`;<br>- the disk will be full in less than 24 hours. | last(/Check Point Next Generation Firewall by SNMP/vfs.fs.pused[multiDiskUsagePercent.{#SNMPINDEX}])>{$DISK.PUSED.MAX.CRIT:"{#DISK.NAME}"} and<br>(last(/Check Point Next Generation Firewall by SNMP/vfs.fs.total[multiDiskSize.{#SNMPINDEX}])-last(/Check Point Next Generation Firewall by SNMP/vfs.fs.used[multiDiskUsed.{#SNMPINDEX}]))<{$DISK.FREE.MIN.CRIT:"{#DISK.NAME}"} | [{"tag": "scope", "value": "capacity"}, {"tag": "scope", "value": "performance"}] | no url |
| {#DISK.NAME}: Disk space is low | WARNING | Two conditions should match:<br>1. The first condition - utilization of the space should be above `{$DISK.PUSED.MAX.WARN:"{#DISK.NAME}"}`.<br>2. The second condition should be one of the following:<br>- the disk free space is less than `{$DISK.FREE.MIN.WARN:"{#DISK.NAME}"}`;<br>- the disk will be full in less than 24 hours. | last(/Check Point Next Generation Firewall by SNMP/vfs.fs.pused[multiDiskUsagePercent.{#SNMPINDEX}])>{$DISK.PUSED.MAX.WARN:"{#DISK.NAME}"} and<br>(last(/Check Point Next Generation Firewall by SNMP/vfs.fs.total[multiDiskSize.{#SNMPINDEX}])-last(/Check Point Next Generation Firewall by SNMP/vfs.fs.used[multiDiskUsed.{#SNMPINDEX}]))<{$DISK.FREE.MIN.WARN:"{#DISK.NAME}"} | [{"tag": "scope", "value": "capacity"}, {"tag": "scope", "value": "performance"}] | no url |


<a name="discovery_voltage_discovery"></a>

## Discovery Voltage discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| {#SENSOR.NAME}: Voltage value | MIB: CHECKPOINT-MIB<br>Most recent measurement obtained by the agent for this sensor. | sensor.volt.value[voltageSensorValue.{#SNMPINDEX}] | DEPENDENT |


<a name="discovery_vpn_discovery"></a>

## Discovery VPN discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| VPN {#VPN.NAME}: Community | MIB: CHECKPOINT-MIB<br>VPN tunnel community. | vpn.tunnel.community[tunnelCommunity.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Tunnel interface | MIB: CHECKPOINT-MIB<br>VPN tunnel interface. | vpn.tunnel.netif[tunnelInterface.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Peer IP address | MIB: CHECKPOINT-MIB<br>VPN peer IP address. | vpn.tunnel.peer_ip[tunnelPeerIpAddr.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Peer type | MIB: CHECKPOINT-MIB<br>VPN peer type. | vpn.tunnel.peer_type[tunnelPeerType.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Link priority | MIB: CHECKPOINT-MIB<br>Link priority. | vpn.tunnel.priority[tunnelLinkPriority.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Probing state | MIB: CHECKPOINT-MIB<br>VPN tunnel probing state:<br>0 - unknown<br>1 - alive<br>2 - dead | vpn.tunnel.prob_state[tunnelProbState.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Source IP | MIB: CHECKPOINT-MIB<br>Source IP address. | vpn.tunnel.src_ip[tunnelSourceIpAddr.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Tunnel state | MIB: CHECKPOINT-MIB<br>VPN tunnel state:<br>3 - active<br>4 - destroy<br>129 - idle<br>130 - phase1<br>131 - down<br>132 - init | vpn.tunnel.state[tunnelState.{#SNMPINDEX}] | DEPENDENT |
| VPN {#VPN.NAME}: Tunnel type | MIB: CHECKPOINT-MIB<br>VPN tunnel type. | vpn.tunnel.type[tunnelType.{#SNMPINDEX}] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| VPN {#VPN.NAME}: Tunnel down | AVERAGE | This trigger expression works as follows:<br>1. It can be triggered if the current tunnel state is down.<br>2. `{$VPN.STATE.CONTROL:"{#VPN.NAME}"}=1` - a user can redefine the context macro to "0", marking this notification as not important. No new trigger will be fired if this tunnel is down. | {$VPN.STATE.CONTROL:"{#VPN.NAME}"}=1 and last(/Check Point Next Generation Firewall by SNMP/vpn.tunnel.state[tunnelState.{#SNMPINDEX}])=131 | [{"tag": "scope", "value": "availability"}] | no url |

