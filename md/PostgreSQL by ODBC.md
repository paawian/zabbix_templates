# PostgreSQL by ODBC template description

This template is designed for the effortless deployment of PostgreSQL monitoring by Zabbix via ODBC and doesn't require any external scripts.

Setup:

1. Create the PostgreSQL user for monitoring (`<password>` at your discretion) and inherit permissions from the default role `pg_monitor`:
CREATE USER zbx_monitor WITH PASSWORD '<PASSWORD>' INHERIT;
GRANT pg_monitor TO zbx_monitor;

2. Edit the `pg_hba.conf` configuration file to allow TCP connections for the user `zbx_monitor`. You can check the PostgreSQL documentation for examples (https://www.postgresql.org/docs/current/auth-pg-hba-conf.html).

3. Install the PostgreSQL ODBC driver.

4. Set up the connection string with the `{$PG.CONNSTRING}` macro. The minimum required parameters are:
- `Driver=` - set the name of the driver which will be used for monitoring (from the `odbcinst.ini` file) or specify the path to the driver file (for example `/usr/lib64/psqlodbcw.so`);
- `Servername=` - set the host name or IP address of the PostgreSQL instance;
- `Port=` - adjust the port number if needed.

If you want to use SSL/TLS encryption to protect communications with the remote PostgreSQL instance, you can also specify encryption parameters here.

It is assumed that you set up the PostgreSQL instance to work in the desired encryption mode. Check the PostgreSQL documentation (https://www.postgresql.org/docs/current/ssl-tcp.html) for details.

For example, to enable required encryption in transport mode without identity checks, the connection string could look like this (replace `<instanceip>` with the address of the PostgreSQL instance):
Servername=<instanceip>;Port=5432;Driver=/usr/lib64/psqlodbcw.so;SSLmode=require

5. Set the password that you specified in step 1 in the macro `{$PG.PASSWORD}`.

You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/384190-%C2%A0discussion-thread-for-official-zabbix-template-db-postgresql

Generated by official Zabbix template tool "Templator"

## Summary
* [items](#items)
* [macros](#macros)
* [triggers](#triggers)
* [discoveries](#discoveries)
  * [Discovery Database discovery ](#discovery_database_discovery)
  * [Discovery Replication discovery ](#discovery_replication_discovery)

<a name="items" />

## Items
| name | description | key | type | delay |
| ------------- |------------- |------------- |------------- |------------- |
| Get archive | Collect archive status metrics. | db.odbc.select[pgsql.archive,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Count of autovacuum workers | Number of autovacuum workers. | db.odbc.select[pgsql.autovacuum.count,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Get bgwriter | Collect all metrics from pg_stat_bgwriter:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-BGWRITER-VIEW | db.odbc.select[pgsql.bgwriter,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Get connections sum | Collect all metrics from pg_stat_activity:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-ACTIVITY-VIEW | db.odbc.select[pgsql.connections.sum,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Get dbstat | Collect all metrics from pg_stat_database per database:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-DATABASE-VIEW | db.odbc.select[pgsql.dbstat,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Get dbstat sum | Collect all metrics from pg_stat_database as sums for all databases:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-DATABASE-VIEW | db.odbc.select[pgsql.dbstat.sum,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Get locks | Collect all metrics from pg_locks per database:<br>https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-TABLES | db.odbc.select[pgsql.locks,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Age of oldest xid | Age of oldest xid. | db.odbc.select[pgsql.oldest.xid,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Ping | Used to test a connection to see if it is alive. It is set to 0 if the query is unsuccessful. | db.odbc.select[pgsql.ping,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Get queries | Collect all metrics by query execution time. | db.odbc.select[pgsql.queries,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Replication: Standby count | Number of standby servers. | db.odbc.select[pgsql.replication.count,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Replication: Lag in bytes | Replication lag with master, in bytes. | db.odbc.select[pgsql.replication.lag.b,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Replication: Lag in seconds | Replication lag with master, in seconds. | db.odbc.select[pgsql.replication.lag.sec,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Get replication | Collect metrics from the pg_stat_replication, which contains information about the WAL sender process, showing statistics about replication to that sender's connected standby server. | db.odbc.select[pgsql.replication.process,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Replication: Recovery role | Replication role: 1 — recovery is still in progress (standby mode), 0 — master mode. | db.odbc.select[pgsql.replication.recovery_role,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Replication: Status | Replication status: 0 — streaming is down, 1 — streaming is up, 2 — master mode. | db.odbc.select[pgsql.replication.status,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Uptime | Time since the server started. | db.odbc.select[pgsql.uptime,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | no delay |
| Version | PostgreSQL version. | db.odbc.select[pgsql.version,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | 15m |
| Get WAL | Collect write-ahead log (WAL) metrics. | db.odbc.select[pgsql.wal.stat,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | ODBC | 5m |
| Archive: Count of archived files | Count of archived files. | pgsql.archive.count_archived_files | DEPENDENT | 0 |
| Archive: Count of files in archive_status need to archive | Count of files to archive. | pgsql.archive.count_files_to_archive | DEPENDENT | 0 |
| Archive: Count of failed attempts to archive files | Count of failed attempts to archive files. | pgsql.archive.failed_trying_to_archive | DEPENDENT | 0 |
| Archive: Size of files need to archive | Size of files to archive. | pgsql.archive.size_files_to_archive | DEPENDENT | 0 |
| Bgwriter: Buffers allocated per second | Number of buffers allocated per second. | pgsql.bgwriter.buffers_alloc.rate | DEPENDENT | 0 |
| Bgwriter: Buffers written directly by a backend per second | Number of buffers written directly by a backend per second. | pgsql.bgwriter.buffers_backend.rate | DEPENDENT | 0 |
| Bgwriter: Times a backend executed its own fsync per second | Number of times a backend had to execute its own fsync call per second (normally the background writer handles those even when the backend does its own write). | pgsql.bgwriter.buffers_backend_fsync.rate | DEPENDENT | 0 |
| Checkpoint: Buffers written during checkpoints per second | Number of buffers written during checkpoints per second. | pgsql.bgwriter.buffers_checkpoint.rate | DEPENDENT | 0 |
| Checkpoint: Buffers written by the background writer per second | Number of buffers written by the background writer per second. | pgsql.bgwriter.buffers_clean.rate | DEPENDENT | 0 |
| Checkpoint: Requested per second | Number of requested checkpoints that have been performed per second. | pgsql.bgwriter.checkpoints_req.rate | DEPENDENT | 0 |
| Checkpoint: Scheduled per second | Number of scheduled checkpoints that have been performed per second. | pgsql.bgwriter.checkpoints_timed.rate | DEPENDENT | 0 |
| Checkpoint: Checkpoint sync time per second | Total amount of time per second that has been spent in the portion of checkpoint processing where files are synchronized to disk. | pgsql.bgwriter.checkpoint_sync_time.rate | DEPENDENT | 0 |
| Checkpoint: Checkpoint write time per second | Total amount of time per second that has been spent in the portion of checkpoint processing where files are written to disk. | pgsql.bgwriter.checkpoint_write_time.rate | DEPENDENT | 0 |
| Bgwriter: Number of bgwriter cleaning scan stopped per second | Number of times the background writer stopped a cleaning scan because it had written too many buffers per second. | pgsql.bgwriter.maxwritten_clean.rate | DEPENDENT | 0 |
| Cache hit ratio, % | Cache hit ratio. | pgsql.cache.hit | CALCULATED | no delay |
| Connections sum: Active | Total number of connections executing a query. | pgsql.connections.sum.active | DEPENDENT | 0 |
| Connections sum: Disabled | Total number of disabled connections. | pgsql.connections.sum.disabled | DEPENDENT | 0 |
| Connections sum: Fastpath function call | Total number of connections executing a fast-path function. | pgsql.connections.sum.fastpath_function_call | DEPENDENT | 0 |
| Connections sum: Idle | Total number of connections waiting for a new client command. | pgsql.connections.sum.idle | DEPENDENT | 0 |
| Connections sum: Idle in transaction | Total number of connections in a transaction state but not executing a query. | pgsql.connections.sum.idle_in_transaction | DEPENDENT | 0 |
| Connections sum: Idle in transaction (aborted) | Total number of connections in a transaction state but not executing a query, and where one of the statements in the transaction caused an error. | pgsql.connections.sum.idle_in_transaction_aborted | DEPENDENT | 0 |
| Connections sum: Prepared | Total number of prepared transactions:<br>https://www.postgresql.org/docs/current/sql-prepare-transaction.html | pgsql.connections.sum.prepared | DEPENDENT | 0 |
| Connections sum: Total | Total number of connections. | pgsql.connections.sum.total | DEPENDENT | 0 |
| Connections sum: Total, % | Total number of connections, in percentage. | pgsql.connections.sum.total_pct | DEPENDENT | 0 |
| Connections sum: Waiting | Total number of waiting connections:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#WAIT-EVENT-TABLE | pgsql.connections.sum.waiting | DEPENDENT | 0 |
| Dbstat: Hit blocks read per second | Number of times per second disk blocks were found already in the buffer cache. | pgsql.dbstat.sum.blks_hit.rate | DEPENDENT | 0 |
| Dbstat: Disk blocks read per second | Number of disk blocks read per second. | pgsql.dbstat.sum.blks_read.rate | DEPENDENT | 0 |
| Dbstat: Blocks read time | Time spent reading data file blocks by backends. | pgsql.dbstat.sum.blk_read_time | DEPENDENT | 0 |
| Dbstat: Blocks write time | Time spent writing data file blocks by backends. | pgsql.dbstat.sum.blk_write_time | DEPENDENT | 0 |
| Dbstat: Conflicts per second | Number of queries canceled per second due to conflicts with recovery (conflicts occur only on standby servers; see pg_stat_database_conflicts for details). | pgsql.dbstat.sum.conflicts.rate | DEPENDENT | 0 |
| Dbstat: Deadlocks per second | Number of deadlocks detected per second. | pgsql.dbstat.sum.deadlocks.rate | DEPENDENT | 0 |
| Dbstat: Backends connected | Number of connected backends. | pgsql.dbstat.sum.numbackends | DEPENDENT | 0 |
| Dbstat: Number temp bytes per second | Total amount of data written per second to temporary files by queries. | pgsql.dbstat.sum.temp_bytes.rate | DEPENDENT | 0 |
| Dbstat: Number temp files per second | Number of temporary files created by queries per second. | pgsql.dbstat.sum.temp_files.rate | DEPENDENT | 0 |
| Dbstat: Rows deleted per second | Number of rows deleted by queries per second. | pgsql.dbstat.sum.tup_deleted.rate | DEPENDENT | 0 |
| Dbstat: Rows fetched per second | Number of rows fetched by queries per second. | pgsql.dbstat.sum.tup_fetched.rate | DEPENDENT | 0 |
| Dbstat: Rows inserted per second | Number of rows inserted by queries per second. | pgsql.dbstat.sum.tup_inserted.rate | DEPENDENT | 0 |
| Dbstat: Rows returned per second | Number of rows returned by queries per second. | pgsql.dbstat.sum.tup_returned.rate | DEPENDENT | 0 |
| Dbstat: Rows updated per second | Number of rows updated by queries per second. | pgsql.dbstat.sum.tup_updated.rate | DEPENDENT | 0 |
| Dbstat: Committed transactions per second | Number of transactions that have been committed per second. | pgsql.dbstat.sum.xact_commit.rate | DEPENDENT | 0 |
| Dbstat: Roll backed transactions per second | Number of transactions that have been rolled back per second. | pgsql.dbstat.sum.xact_rollback.rate | DEPENDENT | 0 |
| WAL: Segments count | Number of WAL segments. | pgsql.wal.count | DEPENDENT | 0 |
| WAL: Bytes received | WAL receive, in bytes. | pgsql.wal.receive | DEPENDENT | 0 |
| WAL: Bytes written | WAL write, in bytes. | pgsql.wal.write | DEPENDENT | 0 |


<a name="macros" />

## Macros
| macro | value |
| ------------- |------------- |
| {$PG.CONFLICTS.MAX.WARN} | 0 |
| {$PG.CONNSTRING} | Servername=localhost;Port=5432;Driver=/usr/lib64/psqlodbcw.so |
| {$PG.CONN_TOTAL_PCT.MAX.WARN} | 90 |
| {$PG.DATABASE} | postgres |
| {$PG.DEADLOCKS.MAX.WARN} | 0 |
| {$PG.LLD.FILTER.APPLICATION} | .+ |
| {$PG.LLD.FILTER.DBNAME} | .+ |
| {$PG.PASSWORD} | <Put the password here> |
| {$PG.QUERY_ETIME.MAX.WARN} | 30 |
| {$PG.SLOW_QUERIES.MAX.WARN} | 5 |
| {$PG.USER} | zbx_monitor |


<a name="triggers" />

## Triggers
| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| Oldest xid is too big | AVERAGE | no description | last(/PostgreSQL by ODBC/db.odbc.select[pgsql.oldest.xid,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"]) > 18000000 | [{"tag": "scope", "value": "availability"}] | no url |
| Service is down | HIGH | Last test of a connection was unsuccessful. | last(/PostgreSQL by ODBC/db.odbc.select[pgsql.ping,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"])=0 | [{"tag": "scope", "value": "availability"}] | no url |
| Service has been restarted | AVERAGE | PostgreSQL uptime is less than 10 minutes. | last(/PostgreSQL by ODBC/db.odbc.select[pgsql.uptime,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"]) < 10m | [{"tag": "scope", "value": "notice"}] | no url |
| Version has changed | INFO | no description | last(/PostgreSQL by ODBC/db.odbc.select[pgsql.version,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"],#1)<>last(/PostgreSQL by ODBC/db.odbc.select[pgsql.version,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"],#2) and length(last(/PostgreSQL by ODBC/db.odbc.select[pgsql.version,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"]))>0 | [{"tag": "scope", "value": "notice"}] | no url |
| Total number of connections is too high | AVERAGE | Total number of current connections exceeds the limit of {$PG.CONN_TOTAL_PCT.MAX.WARN}% out of the maximum number of concurrent connections to the database server (the "max_connections" setting). | min(/PostgreSQL by ODBC/pgsql.connections.sum.total_pct,5m) > {$PG.CONN_TOTAL_PCT.MAX.WARN} | [{"tag": "scope", "value": "performance"}] | no url |


<a name="discoveries" />

## Discoveries
| name | key | description | type | lifetime | delay |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| Database discovery | db.odbc.select[pgsql.db.discovery,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | Discovers databases (DB) in the database management system (DBMS), except:<br>- templates;<br>- default "postgres" DB;<br>- DBs that do not allow connections. | ODBC | no lifetime | 1h |
| Replication discovery | db.odbc.select[pgsql.replication.process.discovery,,"Database={$PG.DATABASE};{$PG.CONNSTRING}"] | Discovers replication lag metrics. | ODBC | no lifetime | 15m |


<a name="discovery_database_discovery" />

## Discovery Database discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| DB [{#DBNAME}]: Database age | Database age. | db.odbc.select[pgsql.db.age,,"Database={#DBNAME};{$PG.CONNSTRING}"] | ODBC |
| DB [{#DBNAME}]: Bloating tables | Number of bloating tables. | db.odbc.select[pgsql.db.bloating_tables,,"Database={#DBNAME};{$PG.CONNSTRING}"] | ODBC |
| DB [{#DBNAME}]: Database size | Database size. | db.odbc.select[pgsql.db.size,,"Database={#DBNAME};{$PG.CONNSTRING}"] | ODBC |
| DB [{#DBNAME}]: Blocks hit per second | Total number of times per second disk blocks were found already in the buffer cache, so that a read was not necessary. | pgsql.dbstat.blks_hit.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Disk blocks read per second | Total number of disk blocks read per second in this database. | pgsql.dbstat.blks_read.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Disk blocks read time per second | Time spent reading data file blocks by backends per second. | pgsql.dbstat.blk_read_time.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Disk blocks write time per second | Time spent writing data file blocks by backends per second. | pgsql.dbstat.blk_write_time.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Detected conflicts per second | Total number of queries canceled due to conflicts with recovery in this database per second. | pgsql.dbstat.conflicts.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Detected deadlocks per second | Total number of detected deadlocks in this database per second. | pgsql.dbstat.deadlocks.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Get dbstat | Get dbstat metrics for database "{#DBNAME}". | pgsql.dbstat.get_metrics["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Backends connected | Number of backends currently connected to this database. | pgsql.dbstat.numbackends["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Temp_bytes written per second | Total amount of data written to temporary files by queries in this database. | pgsql.dbstat.temp_bytes.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Temp_files created per second | Total number of temporary files created by queries in this database. | pgsql.dbstat.temp_files.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples deleted per second | Total number of rows deleted by queries in this database per second. | pgsql.dbstat.tup_deleted.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples fetched per second | Total number of rows fetched by queries in this database per second. | pgsql.dbstat.tup_fetched.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples inserted per second | Total number of rows inserted by queries in this database per second. | pgsql.dbstat.tup_inserted.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples returned per second | Number of rows returned by queries in this database per second. | pgsql.dbstat.tup_returned.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples updated per second | Total number of rows updated by queries in this database per second. | pgsql.dbstat.tup_updated.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Commits per second | Number of transactions in this database that have been committed per second. | pgsql.dbstat.xact_commit.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Rollbacks per second | Total number of transactions in this database that have been rolled back. | pgsql.dbstat.xact_rollback.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of accessexclusive locks | Number of accessexclusive locks for this database. | pgsql.locks.accessexclusive["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of accessshare locks | Number of accessshare locks for this database. | pgsql.locks.accessshare["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of exclusive locks | Number of exclusive locks for this database. | pgsql.locks.exclusive["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Get locks | Get locks metrics for database "{#DBNAME}". | pgsql.locks.get_metrics["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of rowexclusive locks | Number of rowexclusive locks for this database. | pgsql.locks.rowexclusive["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of rowshare locks | Number of rowshare locks for this database. | pgsql.locks.rowshare["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of sharerowexclusive locks | Number of total sharerowexclusive for this database. | pgsql.locks.sharerowexclusive["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of shareupdateexclusive locks | Number of shareupdateexclusive locks for this database. | pgsql.locks.shareupdateexclusive["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of share locks | Number of share locks for this database. | pgsql.locks.share["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Num of locks total | Total number of locks in this database. | pgsql.locks.total["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Get queries | Get queries metrics for database "{#DBNAME}". | pgsql.queries.get_metrics["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries slow maintenance count | Slow maintenance query count for this database. | pgsql.queries.mro.slow_count["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries max maintenance time | Max maintenance query time for this database. | pgsql.queries.mro.time_max["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries sum maintenance time | Sum maintenance query time for this database. | pgsql.queries.mro.time_sum["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries slow query count | Slow query count for this database. | pgsql.queries.query.slow_count["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries max query time | Max query time for this database. | pgsql.queries.query.time_max["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries sum query time | Sum query time for this database. | pgsql.queries.query.time_sum["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries slow transaction count | Slow transaction query count for this database. | pgsql.queries.tx.slow_count["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries max transaction time | Max transaction query time for this database. | pgsql.queries.tx.time_max["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries sum transaction time | Sum transaction query time for this database. | pgsql.queries.tx.time_sum["{#DBNAME}"] | DEPENDENT |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| DB [{#DBNAME}]: Too many recovery conflicts | AVERAGE | The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them.<br>https://www.postgresql.org/docs/current/hot-standby.html#HOT-STANDBY-CONFLICT | min(/PostgreSQL by ODBC/pgsql.dbstat.conflicts.rate["{#DBNAME}"],5m) > {$PG.CONFLICTS.MAX.WARN:"{#DBNAME}"} | [{"tag": "scope", "value": "performance"}] | no url |
| DB [{#DBNAME}]: Deadlock occurred | HIGH | Number of deadlocks detected per second exceeds {$PG.DEADLOCKS.MAX.WARN:"{#DBNAME}"} for 5m. | min(/PostgreSQL by ODBC/pgsql.dbstat.deadlocks.rate["{#DBNAME}"],5m) > {$PG.DEADLOCKS.MAX.WARN:"{#DBNAME}"} | [{"tag": "scope", "value": "availability"}] | no url |
| DB [{#DBNAME}]: Too many slow queries | WARNING | The number of detected slow queries exceeds the limit of {$PG.SLOW_QUERIES.MAX.WARN:"{#DBNAME}"}. | min(/PostgreSQL by ODBC/pgsql.queries.query.slow_count["{#DBNAME}"],5m)>{$PG.SLOW_QUERIES.MAX.WARN:"{#DBNAME}"} | [{"tag": "scope", "value": "performance"}] | no url |


<a name="discovery_replication_discovery" />

## Discovery Replication discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| Application [{#APPLICATION_NAME}]: Get replication | Collect metrics from the "pg_stat_replication" about the application "{#APPLICATION_NAME}" that is connected to this WAL sender, which contains information about the WAL sender process, showing statistics about replication to that sender's connected standby server. | pgsql.replication.get_metrics["{#APPLICATION_NAME}"] | DEPENDENT |
| Application [{#APPLICATION_NAME}]: Replication flush lag | Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written and flushed it (but not yet applied it). This can be used to gauge the delay that synchronous_commit level on incurred while committing if this server was configured as a synchronous standby. | pgsql.replication.process.flush_lag["{#APPLICATION_NAME}"] | DEPENDENT |
| Application [{#APPLICATION_NAME}]: Replication replay lag | Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written, flushed and applied it. This can be used to gauge the delay that synchronous_commit level remote_apply incurred while committing if this server was configured as a synchronous standby. | pgsql.replication.process.replay_lag["{#APPLICATION_NAME}"] | DEPENDENT |
| Application [{#APPLICATION_NAME}]: Replication write lag | Time elapsed between flushing recent WAL locally and receiving notification that this standby server has written it (but not yet flushed it or applied it). This can be used to gauge the delay that synchronous_commit level remote_write incurred while committing if this server was configured as a synchronous standby. | pgsql.replication.process.write_lag["{#APPLICATION_NAME}"] | DEPENDENT |

