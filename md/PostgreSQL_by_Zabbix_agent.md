# PostgreSQL by Zabbix agent template description

This template is designed for the deployment of PostgreSQL monitoring by Zabbix via Zabbix agent and uses user parameters to run SQL queries with the `psql` command-line tool.

Note:
- The template requires `pg_isready` and `psql` utilities to be installed on the same host with Zabbix agent.
- The template requires files with SQL queries and user parameters that can be found in the Zabbix official repository:
https://git.zabbix.com/projects/ZBX/repos/zabbix/browse/templates/db/postgresql?at=refs%2Fheads%2Frelease%2F6.0

Setup:

1. Deploy Zabbix agent and create the PostgreSQL user for monitoring (`<password>` at your discretion) with proper access rights to your PostgreSQL instance.

For PostgreSQL version 10 and above:
CREATE USER zbx_monitor WITH PASSWORD '<PASSWORD>' INHERIT;
GRANT pg_monitor TO zbx_monitor;

For PostgreSQL version 9.6 and below:
CREATE USER zbx_monitor WITH PASSWORD '<PASSWORD>';
GRANT SELECT ON pg_stat_database TO zbx_monitor;
ALTER USER zbx_monitor WITH SUPERUSER;

2. Copy the `postgresql/` directory to the `zabbix` user home directory - `/var/lib/zabbix/`. The `postgresql/` directory contains the files with SQL queries needed to obtain metrics from PostgreSQL instance.

If the home directory of the `zabbix` user doesn't exist, create it first:
mkdir -m u=rwx,g=rwx,o= -p /var/lib/zabbix
chown zabbix:zabbix /var/lib/zabbix

3. Copy the `template_db_postgresql.conf` file, containing user parameters, to the Zabbix agent configuration directory `/etc/zabbix/zabbix_agentd.d/` and restart Zabbix agent service.

If you want to use SSL/TLS encryption to protect communications with the remote PostgreSQL instance, you can modify the connection string in user parameters. For example, to enable required encryption in transport mode without identity checks you could append `?sslmode=required` to the end of the connection string for all keys that use `psql`:
UserParameter=pgsql.bgwriter[*], psql -qtAX postgresql://"$3":"$4"@"$1":"$2"/"$5"?sslmode=required -f "/var/lib/zabbix/postgresql/pgsql.bgwriter.sql"

Consult the PostgreSQL documentation about protection modes (https://www.postgresql.org/docs/current/libpq-ssl.html#LIBPQ-SSL-PROTECTION) and client connection parameters (https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-SSLMODE).

Also, it is assumed that you set up the PostgreSQL instance to work in the desired encryption mode. Check the PostgreSQL documentation (https://www.postgresql.org/docs/current/ssl-tcp.html) for details.

4. Edit the `pg_hba.conf` configuration file to allow connections for the user `zbx_monitor`. You can check the PostgreSQL documentation for examples (https://www.postgresql.org/docs/current/auth-pg-hba-conf.html).

5. Specify the host name or IP address in the `{$PG.HOST}` macro. Adjust the port number with `{$PG.PORT}` macro if needed.

6. Set the password that you specified in step 1 in the macro `{$PG.PASSWORD}`.

You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/384190-%C2%A0discussion-thread-for-official-zabbix-template-db-postgresql

Generated by official Zabbix template tool "Templator"

## Summary
* [items](#items)
* [macros](#macros)
* [triggers](#triggers)
* [discoveries](#discoveries)
  * [Discovery Database discovery ](#discovery_database_discovery)

<a name="items"></a>

## Items
| name | description | key | type | delay |
| ------------- |------------- |------------- |------------- |------------- |
| Bgwriter: Buffers allocated per second | Number of buffers allocated per second. | pgsql.bgwriter.buffers_alloc.rate | DEPENDENT | 0 |
| Bgwriter: Buffers written directly by a backend per second | Number of buffers written directly by a backend per second. | pgsql.bgwriter.buffers_backend.rate | DEPENDENT | 0 |
| Bgwriter: Times a backend executed its own fsync per second | Number of times a backend had to execute its own fsync call per second (normally the background writer handles those even when the backend does its own write). | pgsql.bgwriter.buffers_backend_fsync.rate | DEPENDENT | 0 |
| Checkpoint: Buffers written during checkpoints per second | Number of buffers written during checkpoints per second. | pgsql.bgwriter.buffers_checkpoint.rate | DEPENDENT | 0 |
| Checkpoint: Buffers written by the background writer per second | Number of buffers written by the background writer per second. | pgsql.bgwriter.buffers_clean.rate | DEPENDENT | 0 |
| Checkpoint: Requested per second | Number of requested checkpoints that have been performed per second. | pgsql.bgwriter.checkpoints_req.rate | DEPENDENT | 0 |
| Checkpoint: Scheduled per second | Number of scheduled checkpoints that have been performed per second. | pgsql.bgwriter.checkpoints_timed.rate | DEPENDENT | 0 |
| Checkpoint: Checkpoint sync time per second | Total amount of time per second that has been spent in the portion of checkpoint processing where files are synchronized to disk. | pgsql.bgwriter.checkpoint_sync_time.rate | DEPENDENT | 0 |
| Checkpoint: Checkpoint write time per second | Total amount of time per second that has been spent in the portion of checkpoint processing where files are written to disk. | pgsql.bgwriter.checkpoint_write_time.rate | DEPENDENT | 0 |
| Bgwriter: Number of bgwriter cleaning scan stopped per second | Number of times the background writer stopped a cleaning scan because it had written too many buffers per second. | pgsql.bgwriter.maxwritten_clean.rate | DEPENDENT | 0 |
| Get bgwriter | Collect all metrics from pg_stat_bgwriter:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-BGWRITER-VIEW | pgsql.bgwriter["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Cache hit ratio, % | Cache hit ratio. | pgsql.cache.hit["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Config hash | PostgreSQL configuration hash. | pgsql.config.hash["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | 15m |
| Connections sum: Active | Total number of connections executing a query. | pgsql.connections.sum.active | DEPENDENT | 0 |
| Connections sum: Idle | Total number of connections waiting for a new client command. | pgsql.connections.sum.idle | DEPENDENT | 0 |
| Connections sum: Idle in transaction | Total number of connections in a transaction state but not executing a query. | pgsql.connections.sum.idle_in_transaction | DEPENDENT | 0 |
| Connections sum: Prepared | Total number of prepared transactions:<br>https://www.postgresql.org/docs/current/sql-prepare-transaction.html | pgsql.connections.sum.prepared | DEPENDENT | 0 |
| Connections sum: Total | Total number of connections. | pgsql.connections.sum.total | DEPENDENT | 0 |
| Connections sum: Total, % | Total number of connections, in percentage. | pgsql.connections.sum.total_pct | DEPENDENT | 0 |
| Connections sum: Waiting | Total number of waiting connections:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#WAIT-EVENT-TABLE | pgsql.connections.sum.waiting | DEPENDENT | 0 |
| Get connections sum | Collect all metrics from pg_stat_activity:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-ACTIVITY-VIEW | pgsql.connections.sum["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Get dbstat | Collect all metrics from pg_stat_database per database:<br>https://www.postgresql.org/docs/current/monitoring-stats.html#PG-STAT-DATABASE-VIEW | pgsql.dbstat["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Get locks | Collect all metrics from pg_locks per database:<br>https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-TABLES | pgsql.locks["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Ping time | Used to get the `SELECT 1` query execution time. | pgsql.ping.time["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Ping | Used to test a connection to see if it is alive. It is set to 0 if the instance doesn't accept the connections. | pgsql.ping["{$PG.HOST}","{$PG.PORT}"] | no type | no delay |
| Get queries | Collect all metrics by query execution time. | pgsql.queries["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}","{$PG.QUERY_ETIME.MAX.WARN}"] | no type | no delay |
| Replication: Standby count | Number of standby servers. | pgsql.replication.count["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Replication: Lag in seconds | Replication lag with master, in seconds. | pgsql.replication.lag.sec["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Replication: Recovery role | Replication role: 1 — recovery is still in progress (standby mode), 0 — master mode. | pgsql.replication.recovery_role["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Replication: Status | Replication status: 0 — streaming is down, 1 — streaming is up, 2 — master mode. | pgsql.replication.status["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Transactions: Max active transaction time | Current max active transaction time. | pgsql.transactions.active | DEPENDENT | 0 |
| Transactions: Max idle transaction time | Current max idle transaction time. | pgsql.transactions.idle | DEPENDENT | 0 |
| Transactions: Max prepared transaction time | Current max prepared transaction time. | pgsql.transactions.prepared | DEPENDENT | 0 |
| Transactions: Max waiting transaction time | Current max waiting transaction time. | pgsql.transactions.waiting | DEPENDENT | 0 |
| Get transactions | Collect metrics by transaction execution time. | pgsql.transactions["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Uptime | Time since the server started. | pgsql.uptime["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | no delay |
| Version | PostgreSQL version. | pgsql.version["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | 15m |
| WAL: Segments count | Number of WAL segments. | pgsql.wal.count | DEPENDENT | 0 |
| Get WAL | Collect write-ahead log (WAL) metrics. | pgsql.wal.stat["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | no type | 5m |
| WAL: Bytes written | WAL write, in bytes. | pgsql.wal.write | DEPENDENT | 0 |


<a name="macros"></a>

## Macros
| macro | value |
| ------------- |------------- |
| {$PG.CACHE_HITRATIO.MIN.WARN} | 90 |
| {$PG.CHECKPOINTS_REQ.MAX.WARN} | 5 |
| {$PG.CONFLICTS.MAX.WARN} | 0 |
| {$PG.CONN_TOTAL_PCT.MAX.WARN} | 90 |
| {$PG.DATABASE} | postgres |
| {$PG.DEADLOCKS.MAX.WARN} | 0 |
| {$PG.FROZENXID_PCT_STOP.MIN.HIGH} | 75 |
| {$PG.HOST} | localhost |
| {$PG.LLD.FILTER.DBNAME} | .+ |
| {$PG.LOCKS.MAX.WARN} | 100 |
| {$PG.PASSWORD} | <Put the password here> |
| {$PG.PING_TIME.MAX.WARN} | 1s |
| {$PG.PORT} | 5432 |
| {$PG.QUERY_ETIME.MAX.WARN} | 30 |
| {$PG.REPL_LAG.MAX.WARN} | 10m |
| {$PG.SLOW_QUERIES.MAX.WARN} | 5 |
| {$PG.USER} | zbx_monitor |


<a name="triggers"></a>

## Triggers
| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| Required checkpoints occur too frequently | AVERAGE | Checkpoints are points in the sequence of transactions at which it is guaranteed that the heap and index data files have been updated with all information written before that checkpoint. At checkpoint time, all dirty data pages are flushed to disk and a special checkpoint record is written to the log file.<br>https://www.postgresql.org/docs/current/wal-configuration.html | last(/PostgreSQL by Zabbix agent/pgsql.bgwriter.checkpoints_req.rate) > {$PG.CHECKPOINTS_REQ.MAX.WARN} | [{"tag": "scope", "value": "performance"}] | no url |
| Failed to get items | WARNING | Zabbix has not received any data for items for the last 30 minutes. | nodata(/PostgreSQL by Zabbix agent/pgsql.bgwriter["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],30m) = 1 | [{"tag": "scope", "value": "availability"}] | no url |
| Cache hit ratio too low | WARNING | Cache hit ratio is lower than {$PG.CACHE_HITRATIO.MIN.WARN} for 5m. | max(/PostgreSQL by Zabbix agent/pgsql.cache.hit["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],5m) < {$PG.CACHE_HITRATIO.MIN.WARN} | [{"tag": "scope", "value": "performance"}] | no url |
| Configuration has changed | INFO | PostgreSQL configuration has changed. | last(/PostgreSQL by Zabbix agent/pgsql.config.hash["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],#1)<>last(/PostgreSQL by Zabbix agent/pgsql.config.hash["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],#2) and length(last(/PostgreSQL by Zabbix agent/pgsql.config.hash["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"]))>0 | [{"tag": "scope", "value": "notice"}] | no url |
| Total number of connections is too high | AVERAGE | Total number of current connections exceeds the limit of {$PG.CONN_TOTAL_PCT.MAX.WARN}% out of the maximum number of concurrent connections to the database server (the "max_connections" setting). | min(/PostgreSQL by Zabbix agent/pgsql.connections.sum.total_pct,5m) > {$PG.CONN_TOTAL_PCT.MAX.WARN} | [{"tag": "scope", "value": "performance"}] | no url |
| Response too long | AVERAGE | Response is taking too long (over {$PG.PING_TIME.MAX.WARN} for 5m). | min(/PostgreSQL by Zabbix agent/pgsql.ping.time["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],5m) > {$PG.PING_TIME.MAX.WARN} | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |
| Service is down | HIGH | Last test of a connection was unsuccessful. | last(/PostgreSQL by Zabbix agent/pgsql.ping["{$PG.HOST}","{$PG.PORT}"]) = 0 | [{"tag": "scope", "value": "availability"}] | no url |
| Streaming lag with master is too high | AVERAGE | Replication lag with master is higher than {$PG.REPL_LAG.MAX.WARN} for 5m. | min(/PostgreSQL by Zabbix agent/pgsql.replication.lag.sec["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],5m) > {$PG.REPL_LAG.MAX.WARN} | [{"tag": "scope", "value": "availability"}, {"tag": "scope", "value": "performance"}] | no url |
| Replication is down | AVERAGE | Replication is enabled and data streaming was down for 5m. | max(/PostgreSQL by Zabbix agent/pgsql.replication.status["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],5m)=0 | [{"tag": "scope", "value": "availability"}] | no url |
| Service has been restarted | AVERAGE | PostgreSQL uptime is less than 10 minutes. | last(/PostgreSQL by Zabbix agent/pgsql.uptime["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"]) < 10m | [{"tag": "scope", "value": "notice"}] | no url |
| Version has changed | INFO | no description | last(/PostgreSQL by Zabbix agent/pgsql.version["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],#1)<>last(/PostgreSQL by Zabbix agent/pgsql.version["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"],#2) and length(last(/PostgreSQL by Zabbix agent/pgsql.version["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"]))>0 | [{"tag": "scope", "value": "notice"}] | no url |


<a name="discoveries"></a>

## Discoveries
| name | key | description | type | lifetime | delay |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| Database discovery | pgsql.discovery.db["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}"] | Discovers databases (DB) in the database management system (DBMS), except:<br>- templates;<br>- default "postgres" DB;<br>- DBs that do not allow connections. | no type | no lifetime | 1h |


<a name="discovery_database_discovery" />

## Discovery Database discovery

### Items

| name | description | key | type |
| ------------- |------------- |------------- |------------- |
| DB [{#DBNAME}]: Database size | Database size. | pgsql.db.size["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{$PG.DATABASE}","{#DBNAME}"] | no type |
| DB [{#DBNAME}]: Blocks hit per second | Total number of times per second disk blocks were found already in the buffer cache, so that a read was not necessary. | pgsql.dbstat.blks_hit.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Disk blocks read per second | Total number of disk blocks read per second in this database. | pgsql.dbstat.blks_read.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Detected conflicts per second | Total number of queries canceled due to conflicts with recovery in this database per second. | pgsql.dbstat.conflicts.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Detected deadlocks per second | Total number of detected deadlocks in this database per second. | pgsql.dbstat.deadlocks.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Get dbstat | Get dbstat metrics for database "{#DBNAME}". | pgsql.dbstat.get_metrics["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Temp_bytes written per second | Total amount of data written to temporary files by queries in this database. | pgsql.dbstat.temp_bytes.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Temp_files created per second | Total number of temporary files created by queries in this database. | pgsql.dbstat.temp_files.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples deleted per second | Total number of rows deleted by queries in this database per second. | pgsql.dbstat.tup_deleted.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples fetched per second | Total number of rows fetched by queries in this database per second. | pgsql.dbstat.tup_fetched.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples inserted per second | Total number of rows inserted by queries in this database per second. | pgsql.dbstat.tup_inserted.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples returned per second | Number of rows returned by queries in this database per second. | pgsql.dbstat.tup_returned.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Tuples updated per second | Total number of rows updated by queries in this database per second. | pgsql.dbstat.tup_updated.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Commits per second | Number of transactions in this database that have been committed per second. | pgsql.dbstat.xact_commit.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Rollbacks per second | Total number of transactions in this database that have been rolled back. | pgsql.dbstat.xact_rollback.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Frozen XID before autovacuum, % | Preventing Transaction ID Wraparound Failures:<br>https://www.postgresql.org/docs/current/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND | pgsql.frozenxid.prc_before_av["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Frozen XID before stop, % | Preventing Transaction ID Wraparound Failures:<br>https://www.postgresql.org/docs/current/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND | pgsql.frozenxid.prc_before_stop["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Get frozen XID | no description | pgsql.frozenxid["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{#DBNAME}"] | no type |
| DB [{#DBNAME}]: Num of locks total | Total number of locks in this database. | pgsql.locks.total["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Get queries | Get queries metrics for database "{#DBNAME}". | pgsql.queries.get_metrics["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries slow maintenance count | Slow maintenance query count for this database. | pgsql.queries.mro.slow_count["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries max maintenance time | Max maintenance query time for this database. | pgsql.queries.mro.time_max["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries sum maintenance time | Sum maintenance query time for this database. | pgsql.queries.mro.time_sum["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries slow query count | Slow query count for this database. | pgsql.queries.query.slow_count["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries max query time | Max query time for this database. | pgsql.queries.query.time_max["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries sum query time | Sum query time for this database. | pgsql.queries.query.time_sum["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries slow transaction count | Slow transaction query count for this database. | pgsql.queries.tx.slow_count["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries max transaction time | Max transaction query time for this database. | pgsql.queries.tx.time_max["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Queries sum transaction time | Sum transaction query time for this database. | pgsql.queries.tx.time_sum["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Index scans per second | Number of index scans in the database per second. | pgsql.scans.idx.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Sequential scans per second | Number of sequential scans in this database per second. | pgsql.scans.seq.rate["{#DBNAME}"] | DEPENDENT |
| DB [{#DBNAME}]: Get scans | Number of scans done for table/index in this database. | pgsql.scans["{$PG.HOST}","{$PG.PORT}","{$PG.USER}","{$PG.PASSWORD}","{#DBNAME}"] | no type |


### Triggers

| name | priority | description | expression | tags | url |
| ------------- |------------- |------------- |------------- |------------- |------------- |
| DB [{#DBNAME}]: Too many recovery conflicts | AVERAGE | The primary and standby servers are in many ways loosely connected. Actions on the primary will have an effect on the standby. As a result, there is potential for negative interactions or conflicts between them.<br>https://www.postgresql.org/docs/current/hot-standby.html#HOT-STANDBY-CONFLICT | min(/PostgreSQL by Zabbix agent/pgsql.dbstat.conflicts.rate["{#DBNAME}"],5m) > {$PG.CONFLICTS.MAX.WARN:"{#DBNAME}"} | [{"tag": "scope", "value": "performance"}] | no url |
| DB [{#DBNAME}]: Deadlock occurred | HIGH | Number of deadlocks detected per second exceeds {$PG.DEADLOCKS.MAX.WARN:"{#DBNAME}"} for 5m. | min(/PostgreSQL by Zabbix agent/pgsql.dbstat.deadlocks.rate["{#DBNAME}"],5m) > {$PG.DEADLOCKS.MAX.WARN:"{#DBNAME}"} | [{"tag": "scope", "value": "availability"}] | no url |
| DB [{#DBNAME}]: VACUUM FREEZE is required to prevent wraparound | AVERAGE | Preventing Transaction ID Wraparound Failures:<br>https://www.postgresql.org/docs/current/routine-vacuuming.html#VACUUM-FOR-WRAPAROUND | last(/PostgreSQL by Zabbix agent/pgsql.frozenxid.prc_before_stop["{#DBNAME}"])<{$PG.FROZENXID_PCT_STOP.MIN.HIGH:"{#DBNAME}"} | [{"tag": "scope", "value": "availability"}] | no url |
| DB [{#DBNAME}]: Number of locks is too high | WARNING | no description | min(/PostgreSQL by Zabbix agent/pgsql.locks.total["{#DBNAME}"],5m)>{$PG.LOCKS.MAX.WARN:"{#DBNAME}"} | [{"tag": "scope", "value": "availability"}] | no url |
| DB [{#DBNAME}]: Too many slow queries | WARNING | The number of detected slow queries exceeds the limit of {$PG.SLOW_QUERIES.MAX.WARN:"{#DBNAME}"}. | min(/PostgreSQL by Zabbix agent/pgsql.queries.query.slow_count["{#DBNAME}"],5m)>{$PG.SLOW_QUERIES.MAX.WARN:"{#DBNAME}"} | [{"tag": "scope", "value": "performance"}] | no url |

